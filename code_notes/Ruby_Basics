
#Ruby Basics
##About Ruby
###WORDS IN A PROGRAM
Every word and character in a program has to be valid code for the ruby language. Basically, every word can be one of three possible things:

+ A Ruby keyword, something that's part of the ruby language.
+ Literal data, things like "Strings" and Numbers 1,2.
+ Barewords you define and create, things like variables and methods.

**Anything that isn't one of those is invalid and the Ruby interpreter will throw an error.**

##WHAT IS IRB?

IRB stands for "interactive ruby", it's a ruby shell or REPL. REPL stands for read–eval–print loop. It is a simple, interactive computer programming environment that takes user inputs (such as, in our case, snippets of Ruby code), evaluates them, and returns the result to the user. IRB is run by your computer's terminal. You can think of it as your Ruby playground or execution environment. You can open it up, insert code and execute it to see that code's return value.

**How to run IRB:**

+ type **"irb"** into Terminal and press return
+ to leave irb, type the **"exit"** command

##Reading Error Messages
Error messages have 3 parts:

```lib/a_name_error.rb:3:in `<main>': undefined local variable or method `hello_world' for main:Object (NameError)```

1) The location of the error, the "where".

```lib/a_name_error.rb:3:in `<main>':```

+ `lib/a_name_error.rb` is the file the error occurred in.

+ 3 is the line of code the error.

+ `<main>` is the scope of the error.

2) The description, the "why".

```undefined local variable or method `hello_world' for main:Object```

+ The interpreter does the best job it can to tell you what it thinks went wrong.

3) The type of error, the "who".

`(NameError)`

This is a Ruby Error Type

###NAME ERRORS
NameErrors are caused when a given name is invalid or undefined. Whenever the Ruby interpreter encounters a word it doesn't recognize, it assumes that word is the name of a variable or a method. If that word was never defined as either a variable or a method, it will result in a name error.


###SYNTAX ERRORS
Syntax errors are pretty self-explanatory: they're the result of incorrect syntax. Thankfully, they're usually followed by a guess about the location of the error.

###TYPE ERRORS
When you try and do a mathematical operation on two objects of a different type, you will receive a TypeError. For example if you try and add a string to an integer, Ruby will complain.

###DIVISION ERRORS
DivisionErrors are caused when a given number is divided by 0.

##CLI Applications in Ruby

###CLI FILE STRUCTURE

As our applications increase in complexity we'll have to keep our project files well organized. There's a pretty standard convention for where to put code in a project based on what the code does.

We're going to learn a simplified pattern for organizing code in a Ruby application. We'll build on this structure.

###A SIMPLE RUBY CLI APPLICATION
From the root directory of a Ruby application, you should see a folder structure similar to the following:

```
├── bin
│   └── tictactoe
├── config
│   └── environment.rb
├── lib
│   └── tic_tac_toe.rb
└── spec
    ├── tic_tac_toe_spec.rb
    └── spec_helper.rb
├── Gemfile    
├── ttt.rb   
```
 
You might not have all those folders or those exact files, but you'll have a similar structure.

You'll see top-level directories (the top most folders within your project) such as: `bin`, `lib`, `config`, `spec` and sometimes `app`.

You also might see some top-level files (files located directly within your project) such as: `.learn`, `.rspec`, `Gemfile`, or` Rakefile`. On some labs you might see an actual program file on the top level, like `ttt.rb`.

We try to always tell you where the files you need to read or edit are located in a particular lab. This is just in general.

`cd` into the directory of a lab you recently solved in terminal. **Within that directory type `ls -lah` to list all the files in the current directory, including hidden files, in a human order**. You should see something similar.

Let's talk about what kind of code goes where.

###BIN/

Within the `bin/` directory we generally put code that relates to running our actual program. Our executable files that we put in bin are described below, running CLI applications.

###CONFIG/

A complex program might require 100s of individual files containing source code, method definitions, classes, and more that together constitute all the code required to run the application. We call this code the application's environment. We generally put all the code required to initialize the environment within `config/`. We might see that in an `config/environment.rb` file or even an entire `config/environments` directory.

What does it mean to "initialize a program's environment"? Establishing the environment for your program can involve a number of things, but on the most basic level, the config file or directory is responsible for things like file requirements (i.e. making sure your different files have access to one another), establishing connections to your database (if you have one) and ensuring that your test suite has access to the files that contain the code it is testing.

###LIB/ (APP/)

The `lib/` or Library directory in most Ruby programs and the `app/` directory in Rails projects or complex Ruby programs, is where the majority of our code lives. Within this directory are all the files that define what our program can do. All of the methods and classes our program needs are defined within the files in this directory. One file might define a group of methods that can search for a song by an artist, another file might define a group of methods that can search for a song by a genre. Together these methods might interact to create a Music Search application. **We spend the majority of our time building code in this directory.**

###SPEC/ (TEST/)

Great developers write tests for their code. Whether through the practice of Test-Driven Development or not, it's important to be able to write tests that make sure your code behaves as expected. It's also crucial to be able to read tests and understand the requirements they define for your code. All of our tests go into the `test/` or `spec/` directory.

###.RSPEC, .LEARN, GEMFILE, GEMFILE.LOCK, RAKEFILE

There are a collection of files in most Ruby applications that provide tooling and support for your application. A common such file is `Gemfile`, used by Bundler to manage gem dependencies. Another is a `Rakefile` for defining application tasks. Don't worry too much about these files for now.

**Advanced**: A gem is a library of code that you can include in your Ruby program to lend it the capabilities of that library.

###RUNNING CLI APPLICATIONS

In order to run our program from the command line and allow our user to interact with our program as described above, we need to set up a few things.

First, your program needs a `bin` directory. "Bin" is short for "binary" and is just another way to refer to executable files. Accordingly, your executable files belong in this directory.

**Executable files are any files that contain instructions in a form that a computer's operating system or application can understand and follow**. 

Any executable files we place in our bin directory need to begin with the following line:

`#!/usr/bin/env ruby`

This is often referred to as a "shebang line" and it tells the shell which interpreter to use to execute the remainder of the file.

Using the above setup, you can run your program by typing `ruby bin/< your file name >` into the command line.

Alternatively, you can execute your program by simply typing `./bin/< your file name >` into the command line, since the shebang line at the top of your executable file is already telling the shell to use Ruby to interpret the rest of the file.

Generally our executable file is responsible for running our program. That might include loading required libraries and starting off an execution flow, like telling Ruby to start a game of Tic Tac Toe.

###FILE PERMISSIONS AND CHMOD

For security purposes, a shell environment, including BASH, running within your terminal, requires that executable files are given explicit permission to execute.

When we execute code through the ruby interpreter with the `ruby` command, your shell or terminal has already given the `ruby` command permission to execute code.

But in order for your shell to execute a file via a command like `./bin/<file name>`, you have to grant it execute permissions. We do this using the `chmod` command. You can grant a file execute permissions with:

```
$ chmod +x <file_name>
```

So to grant a file `bin/tictactoe` permissions to execute, you would run: `chmod +x bin/tictactoe`. Depending on your shell environment and user, you might need to run `chmod` with `sudo` (`sudo chmod +x bin/tictactoe`).

All the files provided by Learn already have the correct permissions and this should never cause you a problem. But in the event you need to ever create your own executable, we thought we'd tell you.

###THE CLI INTERFACE

CLI Applications generally follow a similar interface or user experience pattern. Imagine a CLI version of Tic Tac Toe. From a player's perspective, they would start the game by executing the bin for the game.

```
$ bin/tictactoe
```

The program will execute and generally greet the user with some text output:

```
$ bin/tictactoe

Hi! Welcome to Command Line Tic Tac Toe! Would you like to
 play? (Y/n)
```

The CLI will prompt the user for input and will hang until the user types something and presses enter. The CLI generally gives instructions for the expected input at a given prompt. In the example above, the greeting ends by asking the user if they would like to play.

###USER INPUT
The `(Y/n)` at the end is a common convention for telling the user that the following prompt is looking for a "Yes" or "No" input as an answer. It is also saying it expects that input as a single character, either `y` or `n`. The capital `Y` is suggesting the default input if the user types nothing and simply presses enter. Generally CLIs will accept "Yes"/"No" in many forms (`yes`, `no`, `N`, `n`) and still use the `y/n` convention.

```
$ bin/tictactoe

Hi! Welcome to Command Line Tic Tac Toe! Would you like to
 play? (Y/n)
y ↵
Great! Starting a new game...

   |   |   
-----------
   |   |   
-----------
   |   |   

Please select a square by entering 1-9, 1 for the top left 
and 9 for the bottom right:


```

*↵ is a Carriage Return symbol and simply means the "Enter" key was pressed. It is not literal. In the line above it is used to mean that the user entered in the y character at an input prompt and then pressed enter.*

For more complex interactions, the CLI must inform the user about the custom input prompt, just like in the example above: 

```
Please select a square by entering 1-9, 1 for the top left 
and 9 for the bottom right:
``` 

We just tell the player to enter a number, 1 through 9, to represent the square.

```
$ bin/tictactoe

Hi! Welcome to Command Line Tic Tac Toe! Would you like to play? (Y/n)
y ↵
Great! Starting a new game...

   |   |   
-----------
   |   |   
-----------
   |   |   

Please select a square by entering 1-9, 1 for the top left and 9 for the bottom right:
5↵

 O |   |   
-----------
   | X |   
-----------
   |   |   

Please select a square by entering 1-9, 1 for the top left and 9 for the bottom right:
7↵

 O |   |   
-----------
   | X |   
-----------
 X |   |   
```

*Etc...*

That is a simple CLI interface pattern. Whenever you ask the user for input, you will need to:

+ Prompt the user for input: `Would you like to play? (Y/n)`
+ Define the input interface: 

```
Please select a square by entering 1-9, 1 for the top left
 and 9 for the bottom right:
```

+ Accept user input by yielding to a prompt and waiting patiently for the user to press enter. *If the user never enters anything, the program will wait at this state forever until the process is otherwise terminated.*

+ Take the user input and execute the appropriate sub-routine or procedure that represents that feature.

Another pattern is to provide your CLI with a main **program loop** so that it can provide a bigger set of menus and features.

###Program Loop

CLI programs have to continue running and accepting input from the user until they are explicitly exited through sending a termination signal to the program by pressing `CTRL+C` (on OS X, on Windows and other environments it might be `ALT+C` or `COMMAND+C`), or by telling the program to quit or exit through some sort of input.

Imagine a Command Line Jukebox application to browse and play music through the Command Line (like Spotify or iTunes). It might look like this when run:

```
$ bin/jukebox

Hi! Welcome to Command Line Music.

What would you like to do?
I accept: list, play, help, and quit.
help↵

Main Menu Commands:
  help - Brings up this dialog.
  list - Will list all the songs in my collection.
  play - Will prompt for a song to play and play that song.
  quit - Will exit this program

What would you like to do?
I accept: list, play, help, and quit.
list↵

My songs are:
1. Shake It Off, by Taylor Swift
2. In An Aeroplane Over the Sea, by Neautral Milk Hotel
3. Reality Check, by Binary Star
4. Hey boy, hey girl, by the Chemical Brothers

What would you like to do?
I accept: list, play, help, and quit.
play↵

Please enter the song number you would like to play:
3↵

Reality Check, by Binary Star is currently open in your browser.

What would you like to do?
I accept: list, play, help, and quit.
```

Within the transcript of this program you can see the structure of the main application loop.

After the initial greeting, the application begins its main loop, which consists of:

+ Prompting the user for input: What would you like to do?

+ Defining the input interface: `I accept: list, play, help, and quit.`
+ Accepting user input by yielding to a prompt and waiting patiently for the user to press enter. *If the user never enters anything, the program will wait at this state forever until the process is otherwise terminated.*
+ Taking the user input and executing the appropriate sub-routine or procedure that represents that feature. If a user enters 'help', the program should print the help instructions.
+ Once that feature terminates, the program is back at the start of the main loop.

Any CLI application you build that neccesitates a non-binary interface ("Do you want to play Tic Tac Toe?" vs "What game would you like to play?") will have a main loop interface as described above.

##PROJECT STRUCTURE

Check out the file structure below.

```
bin
   |–– greeting
lib
   |–– hello_ruby_programmer.rb
...
```

Let's take a moment to review:

###THE BIN DIRECTORY
The `bin` directory holds our executable file. **This file is responsible for running the program. It contains code that actually enacts the command line interaction––i.e. greeting the user, asking the user for input, storing that input and then acting on it.**

Open up `bin/greeting`. Notice that we are requiring the `lib/hello_ruby_programmer.rb` file.

###THE LIB DIRECTORY
The `lib` directory is where we place the code that our program relies on to run. It is the meat of our CLI application. Our executable file requires the files in the `lib` directory and uses the code (for example, calling on any methods we might define) to to enact the CLI.

Open up `lib/hello_ruby_programmer.rb` file. Notice that it defines a `#greeting` method that is called in the `bin/greeting` file. This is the pattern you'll become familiar with for CLI applications––defining methods in a `lib` directory and calling those methods in `bin` executable files to actually run the program.

Now, let's take a closer look at our code.

###THE CLI PATTERN

In `bin/greeting` you should see the following code:

```
puts "Hi! Welcome to the wonderful world of Ruby programming."
puts "Please enter your name so that we can greet you more
 personally:"
name = gets.strip
greeting(name)
```

Here, we have all of the CLI flow steps outlined above. Let's break it down:

1 . Greet the user:

`puts "Hi! Welcome to the wonderful world of Ruby programming."`

2 . Ask the user for input:

`puts "Please enter your name so that we can greet you more personally:"`

3 . Capture that input using `#gets`

`name = gets.strip`

4 . Use that input to do something else:

`greeting(name)`

In this case, we are passing the user's input into the `#greeting` method as an argument. The greeting method then uses string interpolation to `#puts` out a personalized message.

###THE GETS METHOD

We've talked a lot about capturing and storing a user's input to the terminal and using it in our Ruby program. Now we'll take a closer look at exactly how that happens.

Let's take another look at our code from `bin/greeting`

```
puts "Hi! Welcome to the wonderful world of Ruby programming."
puts "Please enter your name so that we can greet you more personally:"
name = gets.strip
greeting(name)
```

On the third line, the `gets` method is being called. Calling the `gets` method captures the last thing the user typed into the terminal. Whenever your program makes a call to `gets`, it will freeze and wait for user input.

###WAITING FOR THE USER INPUT
If the user never types anything in, your program will wait forever until it is otherwise exited. If you find your tests and your program stalling for long periods of time (anything over 5-10 seconds generally), you might be trapped in a `gets`.

From executing a program, a gets will look like:

![gets in program] (https://dl.dropboxusercontent.com/s/ezddrtyotw5ahow/2015-09-10%20at%2012.12%20PM.png)

From a test run, a stalled gets will look like:

![gets in test] (https://dl.dropboxusercontent.com/s/tijh1wyuvdfz11a/2015-09-10%20at%2012.13%20PM.png)

###RETURN VALUE FOR GETS
The return value of `gets` is the text typed into the terminal. So, setting a variable, `name`, equal to invoking the `gets` method sets that variable equal to the return value of `gets`––the last thing typed into the terminal. Then, the following line uses that `name` variable in string interpolation.

Once we store the return value of `gets` in a variable, we can treat that variable as we would any variable pointing to a string––interpolate with it, convert it to an integer, add it to an array, you name it.

###ADVANCED: HOW GETS GETS INPUT FROM THE TERMINAL
We already know, in general terms, how the puts method outputs text to the terminal, but here's a reminder from an earlier lesson, "Puts, Print and Return":

How do the puts and print methods actually output text to your console? They use the `$stdout` global variable provided to us by Ruby.

The gets method wraps the `$stdin` variable, reading text from the standard input and allowing you to store that text in a variable, so that you can operate on it later.

###SANITIZING USER INPUT: THE STRIP AND CHOMP METHODS
One thing to know about the `#gets` method is that it captures a new line character at the end of whatever input it is storing. We don't want extra whitespace or new lines to be appended to the user input we are trying to store. So, we can chain a call to the `#stripmethod` to remove any new lines or trailing whitespace.

The `#chomp` method works similarly, and you are likely to see `#gets.chomp` used in some examples online. The `#chomp` method removes any new lines at the end of a string while the `#strip` method removes both trailing whitespace and new lines.

##Ruby Data Types
Ruby has **six** data types, which are also known as *classes*: booleans, symbols, numbers, strings, arrays, and hashes.

##STRINGS
###CREATING STRINGS
There are two ways to create a string. In fact, we've already created a string just by typing "hello".

Try it out by opening up IRB, and typing "hello".class

You should see a return value of => String. You can actually call .class on any object to find out what type of data, i.e. what class, it is.

**The Literal Constructor**: This is the method through which we created our "hello" string.

**The Class Constructor**: You can also create a string with String.new. This will create an empty string.

String.new("hello") on the other hand, will create this string: "hello". For the most part, you will create strings using the first method discussed here––simply by enclosing whatever text you want in quotes.

##BOOLEANS

There are only two values of the Boolean data type: **true and false**. In Ruby, however, there is no such thing as a Boolean class. Instead, every appearance, or instance, of true and false in your program are instances of TrueClass and FalseClass respectively.

###NUMBERS

You probably already know from the real world (as opposed to the Ruby world) that integers are numbers. **In Ruby, there are two types of numbers: Fixnums and Floats.**

+ **Fixnums** are *whole numbers*, like 7.

+ **Floats** are *decimal numbers*, like 7.3.

###CREATING INTEGERS

Once again, there is no special magic to creating integers. Simply declare them by typing 9000123 or 2.

###OPERATING ON FIXNUMS AND FLOATS

There are a number of methods available to you for operating on or manipulating integers. You can read more about Fixnums here and more about Floats here For now, we'll just check out a few examples:

~~~
7.5.floor
  => this method will round the float down to the nearest fixnum. Here it will return 7

7.5.ceil
  => 8
10.next
  => 11
~~~

##SYMBOLS

A symbol is a representation of a piece of data. 

Symbols look like this:

~~~
:my_symbol
~~~ 

If I make a symbol, :my_symbol, and then use that symbol later on in my code, my program will refer to the same area of memory in both cases. This is different from, for example, strings, which take up new areas of memory every time they are used.

###CREATING SYMBOLS
You write symbols by placing a : in front of the symbol name.

~~~
:this_is_a_symbol
~~~

##ARRAYS

Arrays are collections of Ruby objects. You can store any type of data in an array.

###WHAT IS AN ARRAY?

So far, we've used variables to store information. For example, I could create a variable called `my_name` and set it equal to my name: `my_name ="Severus Snape"`. However, variables only allow us to store one piece of information at a time.

What if my boss, Headmaster Dumbledore, asks me to deliver the names of all of my students? I could create a bunch of variables like this:

~~~
student_1 = "Harry Potter"
student_2 = "Ron Weasley"
student_3 = "Hermione Granger"
student_4 = "Draco Malfoy"

# etc...
~~~
I could write a program that passes around these variables one at a time. This seems messy though. I could easily forget about a student, for example. Or need to create a new student and then have to hunt through my program for every place I ever passed around all of these individual variables.

If this was real life, Professor Snape would probably just write down all the students in list form and hand that list to Dumbledore. Well, in Ruby, we can do the same thing using an array.

**An array is like a list but in code form.** It is a way for your program to store pieces of data as a collection. *Arrays can contain any data types in any combination––strings, integers, other arrays, hashes, etc.*

Arrays are declared by listing variable names or literals separated by commas (`,`) and wrapped in square brackets `[ ]`. To save our four students from above into an array, we write that in our code like this:

~~~
students = ["Harry Potter", "Ron Weasley", "Hermione 
Granger", "Draco Malfoy"]
~~~


###CREATING ARRAYS
There are a number of ways to create an array. Just like with creating strings, you can use the *literal constructor* or the *class constructor*.

+ **The Literal Constructor**:`[1, 3, 400, 7]` is an array of integers. Any set of comma separated data enclosed in brackets is an array. So, by simply writing something like the above, you can create an array.

	+ `my_array = []`

+ **The Class Constructor**: You can also create an array with the `Array.new` syntax. Just typing `Array.new` will create an empty array (`=> []`).
	+ `my_array = Array.new #=> []`

**Advanced**: A class is like a template, or blueprint, for creating objects in Ruby. An **"object"** is simply a bundle of information and behaviors. 

+ For example, a string is an object, because it contains information (i.e. the text inside the " ") and because it has behaviors––it can do things/have things done to it. 

For example:

	+ `"hi".reverse #=> "ih"`

	
There is an Array class that serves as the blueprint for every array that you will make. This means that all arrays are capable of certain shared behaviors and are responsive to certain methods.

To create a new array object from the Array class, you can call `.new` on `Array` – the name of the class. This creates a brand new, empty array. Don't worry about understanding objects and classes, or the `.new` method, just yet. They are all part of something called Object Oriented Programming, which is a big topic. We'll be building up to it through this and the next few units.

To make an array that isn't empty, you can separate each item, known as an element, by a `,` ("comma") and wrap all the elements inside `[ ]` ("square brackets").

```
puppies = ["bulldog", "terrier", "poodle"]
# => ["bulldog", "terrier", "poodle"]

random_numbers = [ 2, 5, 6, 8, 30050]
# => [ 2, 5, 6, 8, 30050]

mixed = ["this", "array", 7, 20, "has", 45, "integers",
 "&", "strings", 309]
# => ["this", "array", 7, 20, "has", 45, "integers",
 "&", "strings", 309]
```
It is possible to create an array that contains disparate data types, but that is generally discouraged. It's best to keep your arrays populated with only one kind of element.


###OPERATING ON ARRAYS
There are many ways to operate on arrays and on each individual item, or element, within an array. Later on in the course, we'll learn about iteration––the process of operating on each successive item in an array. For now, we'll preview a few array methods:

~~~
[5, 100, 234, 7, 2].sort

  => [2, 5, 7, 100, 234]

[1, 2, 3].reverse
  => [3, 2, 1]
~~~

###RETRIEVING ITEMS FROM ARRAY

When you write out a list on a notepad, you typically write each item on its own line. Whether or not the list is explicitly numbered, the list has a numerical order to it based on the sequence of the lines that the items are listed upon.

Just like the items in our notepad lists, elements in an array are associated with a number that represents their order. In programming, this number is called an **index**. While humans typically start their lists at "1.", arrays begin their indexes at `0` (zero). So, the first item in array will always be "at index `0`". If we have an array of famous (fictional) cats:

`famous_cats = ["Cheshire Cat", "Puss in Boots", "Garfield"]`

The `"Cheshire Cat"` is at index `0` in the array, `"Puss in Boots"` is at index `1`, and `"Garfield"` is at index `2`. **Indexes will always be one less than the count.**

To access one of these items in the `famous_cats` array, we can type the name of the array immediately followed by the relevant index number wrapped in square brackets (`[ ]`).

~~~
famous_cats =  ["Cheshire Cat", "Puss in Boots",
 "Garfield"]

famous_cats[1]  #=> "Puss in Boots"

famous_cats[0] #=> "Cheshire Cat"

famous_cats[2] #=> "Garfield"

famous_cats[20] #=> nil
~~~

###ASSIGNING NEW VALUES TO AN ARRAY

Now that we know how to create an array with literal constructors `[ ]` and read values out of an array via the index of the element like `["Red", "Yellow", "Green"][0]` for `"Red"`, we should learn how to re-assign a value to an index in an array.

`speed_dial = ["Ada", "Kay", "Matz", "DHH", "Borg"]`

We have five of our favorite friends in an array referenced by the local variable `speed_dial`. If we wanted to get the name of the person in the third position of our speed dial, we would call `speed_dial[2]` and it would return `"Matz"`.

But what about replacing someone in our speed dial? How could we replace `"Kay"` in index `1` of `speed_dial` with our new second favorite friend, `"Chipps"`?

To re-assign a value to an index in an array we use the `[ ]=` syntax. We must supply an index we want to re-assign and then a value for that index. For example:

```
speed_dial = ["Ada", "Kay", "Matz", "DHH", "Borg"]
speed_dial[1] #=> "Kay"

speed_dial[1] = "Chipps"
speed_dial[1] #=> "Chipps"
```

Re-assigning a value to an index of an array looks a lot like variable definition and that is by design. Just indicate which index you want to write to with `[ ]`, and then assign it a new value with `=`. The old value is totally forgotten and replaced by the new value.

###MANIPULATING ARRAYS

If an array is a storage container for a list of data, then we can add and remove individual items from it. There are several ways to accomplish either.

###ADDING ITEMS TO AN ARRAY

**SHOVEL METHOD**

The shovel method employs the "shovel" operator `<<` and allows you to **add ("shovel") items onto the end** of an array:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats << "nala cat"

famous_cats #=> ["lil' bub", "grumpy cat", "Maru", 
"nala cat"]
```

The shovel method `<<` is the preferred syntax for adding elements to an array, however you might see other methods used in examples online:

**THE .PUSH METHOD**

Calling `.push` on an array with an argument of the element you wish to add to that array, will also add that element to the end of the array. It has the same effect as the shovel method explained above:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats.push("nala cat")

famous_cats #=> ["lil' bub", "grumpy cat", "Maru", 
"nala cat"]
```

**THE .UNSHIFT METHOD**

To **add an element to the front** of an array, you can call the `.unshift` method on it with an argument of the element you wish to add:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats.unshift("nala cat")

famous_cats.inspect #=> ["nala cat", "lil' bub", "grumpy 
cat", "Maru"]
```

###REMOVING ITEMS FROM AN ARRAY

**THE .POP METHOD**

Calling `.pop` on an array will **remove the last item from the end of the array**. The `.pop` method will also supply the removed element as its return:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]
maru_cat = famous_cats.pop

famous_cats #=> ["lil' bub", "grumpy cat"]
maru_cat #=> Maru
```

**THE .SHIFT METHOD**

Calling `.shift` on an array will **remove the first item from the front of the array**. The `.shift` method will also supply the removed element as a return:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]
lil_bub = famous_cats.shift

famous_cats #=> ["grumpy cat", "Maru"]
lil_bub #=> lil' bub
```

###OPERATING ON ARRAYS

There are a number of other methods available for manipulating arrays. You can learn more about them here, but we'll look at just a few examples together.

**THE .REVERSE METHOD**

This method **reverses an array**.

```
famous_wizards = ["Dumbledore", "Gandalf", "Merlin"]

famous_wizards.reverse #=> ["Merlin", "Gandalf", 
"Dumbledore"]
```

**THE .INCLUDE? METHOD**

This method will **return a boolean of whether or not the array contains (or includes) the element submitted to it inside the parentheses**:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats.include?("Garfield") #=> false

famous_cats.include?("Maru") #=> true
```

**THE .BETWEEN? METHOD**

Returns `false` if obj <=> min is less than zero or if an object <=> max is greater than zero, `true` otherwise.

+ <your value here>.between?(min, max) → true or false 

```
3.between?(1, 5)               #=> true
6.between?(1, 5)               #=> false
'cat'.between?('ant', 'dog')   #=> true
'gnu'.between?('ant', 'dog')   #=> false
```

**THE .EACH METHOD**

Like all classes that include the Enumerable module, Array has an `each` method, which defines what elements should be iterated over and how. In case of Array’s each, all elements in the Array instance are yielded to the supplied block in sequence.

Note that this operation leaves the array unchanged.

```
arr = [1, 2, 3, 4, 5]
arr.each { |a| print a -= 10, " " }
# prints: -9 -8 -7 -6 -5
#=> [1, 2, 3, 4, 5]
```

Another example:

```
#!/usr/bin/ruby

(0..5).each do |i|
   puts "Value of local variable is #{i}"
end
This will produce the following result:

Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
Value of local variable is 5
```

Another sometimes useful iterator is `reverse_each` which will iterate over the elements in the array in reverse order.

```
words = %w[first second third fourth fifth sixth]
str = ""
words.reverse_each { |word| str += "#{word} " }
p str #=> "sixth fifth fourth third second first "
```
**.TIMES METHOD**

Ruby program that uses times

```
# Use a times-loop.
4.times do
    puts "a"
end

# Use a times iterator with an iteration variable.
5.times do |i|
    puts i
end

# Output

a
a
a
a
0
1
2
3
4
```
##NESTED ARRAYS

###What is a Nested Array?

An array is like a list but in code form. It is a way for your program to store pieces of data as a collection. **Arrays can contain any data types in any combination - strings, integers, even other collections like arrays and hashes.**

We know that arrays can contain any type of data, even other arrays. Let's see that in action:

```
nested_students = [
  ["Mike", "Grade 10", "A average"],
  ["Tim", "Grade 10", "C average"],
  ["Monique", "Grade 10", "B Average"]
]
```

A nested, or multidimensional array, is an array whose individual elements are also arrays.

###Why Use a Nested Array?

Nested arrays are useful for storing groups of similar data. One example of nested array usages comes to us from the Google Maps API. Google Maps provides a Javascript function that you, the developer, can use to add Google Maps to your own website. Don't worry about Javascript right now, just understand that a Javascript function is like a Ruby method.

The map-making function (or method, as we're going to think of it) was designed to take in an argument of a nested array - an array in which each index element is an array that contains a place name, latitude and longitude. In other words, something that looks like this:

```
location_array =  [
  ["The Flatiron School", 40.705329, -74.013970],
  ["Disney World", 28.385233, -81.563874]
]
```

###Reading and Writing With Nested Arrays

**ACCESSING DATA FROM A NESTED ARRAY**

To access data from and add data to (i.e. "read and write") with a nested array, we can use the same methods we've been using to deal with one-dimensional arrays.

Let's stick with our `students` and `nested_students` arrays for now. To grab an element out of the `students` array, we used bracket notation, plus the index number of the element we want.

```
students = ["Mike", "Tim", "Monique"]
students[0] #=> "Mike"
```

To access the same student's name from our `nested_students` array, we use bracket notation to drill down into the level of the array we want to access.

```
nested_students = [
  ["Mike", "Grade 10", "A average"],
  ["Tim", "Grade 10", "C average"],
  ["Monique", "Grade 11", "B average"]
]

nested_students[0][0] #=> "Mike"
```

The first set of brackets refers to the top-level of the array - the array that contains all of the other arrays.

```
nested_students[0] #=> ["Mike", "Grade 10", "A average"]
```

We can see that the return value of `nested_students[0]` is the element at index 0 of the nested_students array. That element happens to be an array that looks like this:

```
["Mike", "Grade 10", "A average"]
```

If you set the return value of calling `nested_students[0]` equal to a variable, we can then operate on it with further bracket notation:

```
mike = nested_students[0]
mike[0] #=> "Mike"
```

The syntax that we used earlier on: `nested_students[0][0]` is simply the chaining of method calls - we are calling the `[]` method on the return value of calling the `[]` method on `nested_students`.

Let's try that again. This time, let's write a line of code that returns the grade level of the last student in the nested_students array. Give it a shot in IRB yourself before reading on.

```
nested_students[2][1] #=> "Grade 11"
```

We are accessing the element at index 2 of the `nested_students` array, which is the last element in that array. That element happens to be an array with three index elements, the second of which (the element at index 1) is the grade level of the student. So, `nested_students[2]` grabs us the array that describes the last student in the list, and chaining on `[1]` grabs the value of the element at index 1 of *that* array - the string `"Grade 11"`.


**ADDING DATA TO A NESTED ARRAY**

To add data to a nested array, we can use the same `<<`, or shovel, method we use to add data to a one-dimensional array.

To add another student to our students array:

```
students = ["Mike", "Tim", "Monique"]
students << "Sarah"
students #=> ["Mike", "Tim", "Monique", "Sarah"]
```

To add an element to an array that is nested inside of another array, we use the same bracket notation that we used above to access that nested array, then we can use the `<<` on it.

Let's add another piece of info, `"Class President"` to the nested array that describes `Monique`.

First, we have to access that particular array, the one that describes our student, Monique.

```
nested_students[2]
```

Then, we can use the `<<`.

```
nested_students[2] << "Class President"
```

Now, our `nested_students` array looks like this:

```
nested_students = [
  ["Mike", "Grade 10", "A average"],
  ["Tim", "Grade 10", "C average"],
  ["Monique", "Grade 11", "B average", "Class President"]
]
```

**Iterating Over Nested Arrays**

When we are dealing with a one-dimensional array and we want to do something to every element of the array, we iterate, using methods like `#each` and `#collect`. If, for example, we wanted to puts out every member of the `students` array, we can do so like this:

```
students.each do |student|
  puts student
end
```

In order to manipulate or operate on each element of a nested array, we must iterate down into that level of the array. For example, if you run the following code in IRB:

```
nested_students.each do |student_array|
  puts student_array
end
```

You will have outputted:

```
["Mike", "Grade 10", "A average"]
["Tim", "Grade 10", "C average"]
["Monique", "Grade 11", "B average", "Class President"]
```

So, inside the iteration above, we are accessing the list of arrays that make up the top level of the `nested_students` array. If we want to get *inside* of each child array, we continue to iterate, *inside* of the first iteration.

```
nested_students.each do |student_array|
  student_array.each do |student_detail|
    puts student_detail
  end
end
```

Copy and paste the above code into IRB. You should see the following output:

```
Mike
Grade 10
A average
Tim
Grade 10
C average
Monique
Grade 11
B average
Class President
```
###More Nested Arrays

Let's take a look at some multidimensional arrays that have an even deeper nested than the 2D arrays we've just practiced with.

```
very_nested_array = [
  ["this", "is", "the", "first", "child", ["this", "is", "the", "grandchild"]],
  ["now", "we're", "back", "in", "the", "second", "level", ["now", "we're", "back", "in", "the", "grandchild", "level"]]
]
```

In this array we have the top-level, or parent array that contains two children arrays. The array that is the first index element of this parent array contains six elements, the last of which is yet another array. The array that is the second index element of the parent array contains eight elements, the last of which is yet another array. Here, we have three levels of nesting.

###WHEN TO USE A 3D ARRAY

Multidimensional arrays, like the deeply nested one above, are useful for storing hierarchical data. Any collection of information that you can picture like a tree could be a good candidate for a nested array.

Let's take, for example, a music library. You have artists, which each have albums, which in turn have songs. You could picture a structure like this:

![structure of data] (http://readme-pics.s3.amazonaws.com/Screen%20Shot%202015-09-17%20at%2011.55.01%20AM.png)

And so on, for the various artists in the library. This data structure is considered hierarchical. We could represent it in a nested array that looks something like this:

```
music_library = [["Adele", ["19", ["Day Dreamer", "Best For Last"]], ["21", ["Rollin' In The Deep", "Rumor Has It"]]], ["Beyonce", ["4", ["1 + 1", "Countdown"]], ["Beyonce", ["Haunted", "Pretty Hurts"]]]]
```

When we are working with 3D arrays, it can be difficult to read through the data structure in a way that makes sense. A useful tactic can be formatting the array such that each level of nested is placed on it's own line. This can make things much easier to read:

```
music_library = [
  ["Adele",
    ["19",
      ["Day Dreamer", "Best For Last"]
    ],
    ["21",
      ["Rollin' In The Deep", "Rumor Has It"]
    ]
  ],
  ["Beyonce",
    ["4",
      ["1 + 1", "Countdown"]
    ],
    ["Beyonce",
      ["Haunted", "Pretty Hurts"]
    ]
  ]
]
```

Let's try iterating over our music_library array.

```
music_library.each do |artist_array|
  artist_array.each do |artist_element|
    # we are inside the first level of the array
    # artist_element = ["Adele", ["19", ["Day Dreamer", "Best For Last"]], ["21", ["Rollin' In The Deep", "Rumor Has It"]]]

    if artist_element.class != Array
      puts "Artist: #{artist_element}"
    else
      artist_element.each do |album_element|
        # we are inside the second level of the array,
        # album_element = ["19", ["Day Dreamer", "Best For Last"]]
        if album_element.class != Array
          puts "Album: #{album_element}"
        else
          album_element.each do |song_element|
            # we are inside the third level of the array
            # song_element = "Day Dreamer"
            puts "Song: #{song_element}"
          end
        end
      end
    end
  end
end
```

We begin by iterating over the first child array, the array that contains all of the information about a particular artist:

```
music_library.each do |artist_array|
  artist_array.each do |artist_element|
    # etc...
  end
end
```

At this level, we are accessing the two child arrays that make up the first tier of the `music_library`. On the first step of, or time through, the iteration, `artist_element` is equal to `["Adele", ["19", ["Day Dreamer", "Best For Last"]], ["21", ["Rollin' In The Deep", "Rumor Has It"]]]`.

We have two checks to put in place if we want to keep iteration. Some of the elements of the `artist_element` array are other arrays. These need to be iterated over so that we can access what is inside (i.e. information about the albums and songs). But! Some of the elements are just strings. **We can't iterate over a string** (you might be thinking). Well, you're absolutely right. Since we can't iterate over a string...we won't! Instead, we'll use if/else statements to check to see if an element is an array. If it is, we'll iterate over it, if it isn't, we'll simply puts it out to the terminal.

```
music_library.each do |artist_array|
  artist_array.each do |artist_element|
    if artist_element.class != Array # check to see if the element is not an array
      puts "Artist: #{artist_element}"
    else # i.e., if the element is an array
      artist_element.each do |album_element|
        # Second level of the iteration
      end
    end
  end
end
```

At the second level of our iteration (where we left off with our Second level of the iteration note above), we are operating on the arrays nested inside the arrays that describe each artist. On the first step, or time through, the iteration, `album_element` is equal to `["19", ["Day Dreamer", "Best For Last"]]`.

Once again, some of the members of this array are other arrays, some are strings. So, we need to re-use our `if/else` logic to determine whether or not we should iterate.

```
# ...
artist_element.each do |album_element|
  if album_element.class != Array
    puts "Album: #{album_element}"
  else
    album_element.each do |song_element|
      # Last level of the iteration
    end
  end
end
# ...
```

Once we are iterating over the `album_elements` that are arrays, we are at the bottom of our `music_library`. There are no more arrays to identify and iterate over. So, all we need to do inside that iteration is puts out each `song_element`.

Let's take a look at the whole thing again:

```
music_library.each do |artist_array|
  artist_array.each do |artist_element|
    if artist_element.class != Array
      puts "Artist: #{artist_element}"
    else
      artist_element.each do |album_element|
        if album_element.class != Array
          puts "Album: #{album_element}"
        else
          album_element.each do |song_element|
            puts "Song: #{song_element}"
          end
        end
      end
    end
  end
end
```
###WHEN NOT TO USE A 3D ARRAY

Three levels deep is about as deep as you want to go when constructing multidimensional arrays. As you can see, things can get messy, fast. If you have more hierarchical data than can fit in a 3D array, it might be better to try using a dictionary-like data structure, called a hash, instead.

##METHODS

###WHY USE METHODS
**Methods define a new thing that your program can do.** Variables are a mechanism to teach your Ruby program about data; methods teach your Ruby program about a new routine or behavior it can use. **Variables are like nouns, methods are like verbs.**

For example, imagine needing to say "Hello World!" ten times. The method would look like this:

```
def say_hello_world_ten_times
  phrase = "Hello World!"
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
end
```
Now, when we use the bareword `say_hello_world_ten_times` in our program, it will invoke the method, running the code within the method. 

###DEFINING A METHOD
You can define a method in Ruby with the `def` keyword. A method's name can begin with any lowercase letter. Here's a quick example:

```
def greeting # Method Signature
  puts "Hello World" # Method Body
end # Method Closing
```

+ That first line, `def greeting`, is called the **method signature**, it defines the basic properties of the method including the name of the method, `greeting`.

+ Once you open a method definition with the `def` keyword, all subsequent lines in your program are considered the **method's body**, the actual procedure or code that your method will run every time it's called.

+ You must terminate every opening `def` of a method with a corresponding `end` in order to close the method body.

+ It's also a great practice to indent methods correctly. **The body of a method should be indented two (2) spaces**, placing it visually within the method. When you `end` the method, go back to the same indentation of the `def`, aligning the opening and closing of the method visually.

**NOTE**: Programmers love conventions, or agreed upon rules that help them talk to each other about code. A common convention for Ruby methods is to preface them with a `#`, and in subsequent lessons, you might see methods written with a `#` in front of the method name. This is so that other rubyists can instantly recognize it as a method, as opposed to a variable or a bareword or a class. For example, if a method is named '`greeting`', rubyists will often refer to it as '`#greeting`'. But remember that when you write it in your code, it should be `greeting` and not `#greeting`.

**ANOTHER WAY TO DEFINE METHODS**

Now that we've specified a name for our new method, we may need to declare some parameters. These are simply a list of local variable names in parentheses. Some sample method declarations are

```
def myNewMethod(arg1, arg2, arg3)     # 3 arguments
  # Code for the method would go here
end

def myOtherNewMethod                  # No arguments
  # Code for the method would go here
end
```

Ruby lets you specify default values for a method's arguments---values that will be used if the caller doesn't pass them explicitly. This is done using the assignment operator.

```
def coolDude(arg1="Miles", arg2="Coltrane", arg3="Roach")
  "#{arg1}, #{arg2}, #{arg3}."
end
coolDude	»	"Miles, Coltrane, Roach."
coolDude("Bart")	»	"Bart, Coltrane, Roach."
coolDude("Bart", "Elwood")	»	"Bart, Elwood, Roach."
coolDude("Bart", "Elwood", "Linus")	»	"Bart, Elwood, Linus."
```

The body of a method contains normal Ruby expressions, except that you may not define an instance method, class, or module within a method. The return value of a method is the value of the last expression executed, or the result of an explicit return expression.

##METHODS AND ARGUMENTS

###UNDERSTANDING ARGUMENTS

Imagine needing to build a method that greets a person. We could code something like this:

```
def greeting
    puts "Hi, Ruby programmer!"
end
```

This method, when called, will print out to the terminal, the string `"Hi, Ruby programmer!"`. 

You should see:

```
Hi, Ruby programmer!
 => nil 
```
 
As amazing as this method is, it's still pretty literal. It hard-codes, or directly specifies, name of the person we are greeting as `"Ruby programmer"`. If we wanted to build a method that can greet anyone, even Python programmers, we'd have to re-implement the majority of the original logic from greeting:

```
def greeting_python
  puts "Hello, Python programmer!"
end
```

Notice the only things that changed are the method name and the language name `"Python"` in the body of the method. It's as though that information should be specifiable or configurable when you call the method, otherwise we'd have to build every permutation of the method. In other words, we'd have to re-write the method for every single person we want to greet. We want our method to be more dynamic, more abstract, more re-usable. It should maintain the elements that will always be the same, no matter who we greet, and allow us to change, or swap out, the name of the person we are greeting. **This is dynamic, as opposed to "hard-coded"**.

**Good news, that's exactly what method arguments (also called parameters) are for**:

```
def greeting(name)
  puts "Hello, #{name}!"
end
```

Above, we define our method to take in an argument by following the method name with parentheses enclosing a variable name: `greeting(name)`.

Then, we use **string interpolation** inside the method body to `puts` out a greeting using whatever `name` was passed into the argument when the method is called. String interpolation allows users to use a Ruby variable to render a value inside of a string. In other words, if we have a variable, `name`, that points to a value of `"Sophie"`, string interpolation will let us use that `name` variable inside a string to render, or `puts` out, a string that contains the word `"Sophie"`.

To interpolate a variable into a string, wrap that variable name inside curly braces, preceded by a pound sign: `#{variable_name}`.

Let's call our method and see it in action:

```
greeting("Sophie")
# > Hello, Sophie!
```

###DEFINING METHOD ARGUMENTS

To add arguments to a method, you specify them in the method signature––the line that starts with `def`. Simply add parentheses after the name of the method and create a placeholder name for your argument.

For example, if I want to write a method called `greeting` that accepts an argument of a person's name, I would do it like this:

```
    #method name      #argument
def greeting_a_person(name)
  "Hello #{name}"
end
```

Arguments create new local variables that can be used within the method. When you name an argument, you are defining what bare word you want to use to access that data, just like when you create a variable. **Arguments follow the same rules as local variables: they can be any word that starts with a lowercase letter and they should be as descriptive of the data as possible.**

In our `#greeting` method example, we are saying: When you call the `#greeting` method with an argument of `"Sophie"`, set a variable `name` equal to the value of `"Sophie"`.

###DEFINING METHODS WITH MULTIPLE ARGUMENTS

You can define a method to accept as many arguments as you want. Let's try creating a method that accepts two arguments: a person's name and their programming language of choice.

```
  # method name      first_argument, second_argument
def greeting_programmer(name, language)
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end


greeting_programmer("Sophie", "Ruby")
# > Hello, Sophie. We heard you are a great Ruby programmer. 

greeting_programmer("Steve", "Elixir")
# > Hello, Steven. We heard you are a great Elixir programmer.
```

**To accept multiple arguments, simply separate the bare words in the argument list with commas.**

###REQUIRED ARGUMENTS

Once you define arguments for a method, they become required when you invoke or call the method. If you define a method that accepts a singular argument, when you call that method, you must supply a value for that argument, otherwise, you get an `ArgumentError`. Here's an example:

```
def greeting(name)
  puts "Hello, #{name}!"
end

greeting # I explicitly call the method without a value for 
the argument `name`
# > ArgumentError: wrong number of arguments (0 for 1)
```

In Ruby, all arguments are required when you invoke the method. You can't define a method to accept an argument and call the method without that argument. Additionally, a method defined to accept one argument will raise an error if called with more than one argument.

```
def greeting(name)
  puts "Hello, #{name}!"
end

hello("Sophie", "Ruby") # The method accepts 1 argument and 
I supplied 2.
# > ArgumentError: wrong number of arguments (2 for 1)
```

By default, all arguments defined in a method are required in order to correctly invoke (or "call", or "execute") that method.

###USING ARGUMENTS IN METHODS

Now that we know how to define a method with arguments, let's take a closer look at using those arguments, that data, within the method. Once again, our greeting method:

```
def greeting(name)
  puts "Hello, #{name}"
end
```

When we define a method with arguments we are defining a bareword that we can use to reference the actual value supplied to the method upon invocation. We built a method that will greet a specified person. In order to write code in our method to actually greet any given person, we need a placeholder––a way to refer to a generic person's name. This is an argument.

When we build that method we might ask ourselves, "who is this method designed to greet?". The answer is "anyone, it doesn't matter." That's what makes the method abstract, the detail of who it greets is hidden until the method is actually invoked: greeting("Sophie"). Only then do we know that the method greets Sophie. The value of name is only supplied upon invocation.

The bareword, in this case name, that we use as the argument's name in the method signature becomes a local variable within the method. Through that variable we can reference the value of the argument supplied at invocation.

With the code above, when we say: greeting("Sophie"), the value of the argument name is "Sophie". During the particular runtime invoked by greeting("Sophie"), any reference to name will have the value of "Sophie", allowing the method to behave as intended.

Similarly, when we say: greeting("Ann"), the value of the argument name is "Ann".

Method arguments simply create local variables for you to refer to the value used when the method is actually invoked.

###A NOTE ON METHODS ENDING IN A ?

Conventionally, we name methods that return either `true` or `false` with a question, ending in a literal question mark. One of the most appealing features of Ruby, especially from the point of view of beginner programmers, is it's readability. Ruby lends itself especially well to elegant and sensical statements. So, if our method is meant to answer the question: "is this position taken?", we will phrase our method definition just like that.

##WHY OPTIONAL ARGUMENTS?

We should constantly strive for our code to be dynamic and flexible. As programmers, we are lazy (which is a virtue). Consequently, we want the code we write to be re-usable.

If we define a method, `#greeting`, like this:

```
def greeting
  puts "Hello, Ruby programmer!"
end
```

We have to re-define or re-write that method every time we'd like to use it to greet someone else who might not be a Ruby programmer. Since that's way too much work for us, we'll define our method to take in an argument of someone's name:

```
def greeting(name)
  puts "Hello, #{name}"
end
```

Now our method is flexible and dynamic, it can be used again and again to greet different people.

But what if we don't know the name of the person we are trying to greet? We can make this method even more flexible by making the name argument optional. We do this by using optional, or default, arguments.

###DEFAULT ARGUMENTS

In order to define a method that optionally takes in an argument, we define our method to take in an argument with a default value. By defining our method with default arguments, we make it possible to call the method with optional arguments, i.e. with or without arguments.

```

#             assigning a default value
def greeting(name = "Ruby programmer")
  puts "Hello, #{name}"
end
```

In our argument list, `(name = "Ruby programmer")`, we simply assign the argument name a default value of `"Ruby programmer"`. By doing so, we are really saying:

If the method is invoked without any arguments, i.e. like this: `greeting`, Ruby will assume the value of the `name` variable inside the method to be `"Ruby programmer"`.

However, if the method is invoked with an argument, `greeting("Sophie")`, Ruby will assign the variable `name` to the string `"Sophie"` inside the method.

```
greeting
# > Hello, Ruby programmer!

greeting("Sophie")
# > "Hello, Sophie!"
```

With default arguments, our once simple machine becomes profoundly useful and abstract.

###ADDING DEFAULT ARGUMENTS

Default arguments are easy to add, you simply assign them a default value with = ("equals") in the argument list. There's no limit to the amount of arguments that you can make default.

```
def greeting(name="Ruby programmer", language="Ruby")
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end
```

Let's take a look at the different ways we can call this method:

```
greeting
# > Hello, Ruby programmer. We heard you are a great Ruby programmer. 

greeting("Sophie")
# > Hello, Sophie. We heard you are a great Ruby programmer. 

greeting("Steven", "Elixir")
# > Hello Steven. We heard you are a great Elixir programmer.
```

###USING DEFAULT ARGUMENT AND REQUIRED ARGUMENTS

It is possible to define a method that takes in both required and default arguments. To do so, however, we must place the default argument at the end of the argument list in the method definition.

Take a look:

```
def greeting(name, language="Ruby")
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end
```

Let's call our `#greeting` method with and without an explicit `language` argument:

```
greeting("Sophie", "Ember.js")
# > Hello, Sophie. We heard you are a great Ember.js programmer. 

greeting("Dan")
# > Hello, Dan. We heard you are a great Ruby programmer.
```

It works! Why must we place the default argument at the end of the argument list?

Let's take a look at what would happen if we didn't:

```
def greeting(language="Ruby", name)
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end
```

Now, what happens when we try to call our method without an explicit `language` argument?

```
greeting("Sophie")
```

You might expect it to break. Or you might expect it think that the `language` variable is being set equal to `"Sophie"` in this method call.

Neither of those things will happen. The method will work as we intended because Ruby is smart and has a few tricks up its sleeve to help determine what method arguments are being used where in a method's body.

However, defining the default argument first is confusing. We can understand this from our very reasonable expectations that the above method invocation would break. For this reason, it is conventional to place any default arguments at the end of an argument list when defining a method that takes in both required and default arguments.

##VARIABLES

###What's a CONSTANT

A Constant is a variable type in Ruby that has a larger scope than our local variables, namely, methods can read values from constants defined outside the method. **Constants are a variable type for data that is unlikely to change. You can define a constant by starting the variable definition with a capital letter.**

###HOW YOU INTERPOLATE VARIABLES INTO STRINGS

To interpolate, you wrap the variable like `#{this}`.

Let's try:

```
puts "There are #{num_of_attendees} people coming to
 Beyonce's birthday party."
```
This prints `There are 547 people coming to Beyonce's birthday party.`

###ANOTHER WAY TO INTERPOLATE VARIABLES INTO STRINGS

Some Rubyists write this another way, like this:

```
answer = "Flamboyance"
puts "A group of flamingos is called a " + answer + "."
```
##BOOLEANS AND FLOW CONTROL

Many programming languages, including Ruby, have native **boolean (true or false)** data types. In Ruby they're expressed directly as `true` and `false`.

These boolean values come in handy in programming when we want to implement control flow. **Control flow** is the idea that we can tell our program to execute certain lines of code based upon certain conditions.

+ **For example**, *if* I am tired, then I will take a nap. Otherwise, I will keep reading this insightful and informative readme. You could also invert the perspective like in this example:

	+ If it is *true* that I am tired, then I will take a nap. If it is *false* that I am tired, then I won't take a nap.

Flow control is predicated on these true-or-false boolean values. The adjectives "truthy" and "falsey" are a programming convention for describing the *state* of being true and the state of being false.

What this example amounts to is this: we want to be able to use non-boolean values (like strings or integers) in a boolean context; we want to be able to say, "*if* a certain statement *evaluates* to true (or is "truthy"), then execute these certain lines of code."

Consequently, Ruby must have a way of determining what counts as true at a given moment—or what is "truthy" versus what is "falsey".

###WHAT IS 'TRUTHY' AND 'FALSEY' IN RUBY?

Programming languages are software, too! That means the people who built Ruby had to decide what is truthy and what is falsey. Different languages make different decisions.

**In Ruby only `false` and `nil` are falsey. Everything else is truthy (yes, even `0` is truthy).**

Become familiar with the following chart:

Value |	Truthy?
------|---------------
0	| yes
" " |	yes
"hello" |	yes
nil	| no
6.7 |	yes
true |	yes
false |	no
[1,2]	| yes
{:hi=>"there"}	| yes

**Top-Tip**: Even an empty string, `" "`, is truthy! This might seem kind of strange, but it will make more sense once we learn more about object orientation. For now, keep in mind that even an empty string is an instance of the String class. 

###BONUS: DETERMINING TRUTHINESS
If you forget to memorize this handy chart, there is a trick you can use to determine if a value is truthy or falsey.
A **single bang operator**, `!`, will negate the boolean value it is placed in front of. For example:

```
!true  #=> false
```

and

```
!false #=> true
```

**The double bang operator**: A "double-bang operator" (`!!`) will return `true` or `false` based on whether a value is truthy or falsey to begin with.

For example:

```
!!"hello" #=> true

!!nil #=> false
```

##BOOLEANS
We've already learned a bit about the boolean (true-or-false) data type. In Ruby, a boolean refers to a value of either `true` or `false`, both of which are defined as their very own data types. Every appearance, or instance, of `true` in a Ruby program is an instance of `TrueClass`, while every appearance of `false` is an instance of `FalseClass`.

For now, we don't need to understand the concept of classes in depth. Just know that classes serve as templates for Ruby objects. Think of `TrueClass` and `FalseClass` like cookie cutters––there is a `TrueClass` cookie cutter and a `FalseClass` cookie cutter and every appearance of `true` or `false` is like a cookie made with its respective cookie cutter.

##BOOLEAN OPERATORS

###WHAT ARE BOOLEAN OPERATORS?
Boolean operators are really methods which means that they have return values. What do they return? `true` or `false` of course!

**In Ruby there are three main boolean operators**:

+ `!` ("single-bang") which represents **"NOT"**

+ `&&` ("double-ampersand") which represents **"AND"**

+ `||` ("double-pipe") which represents **"OR"**.

For an `&&` ("and") to evaluate to `true`, both values of either side of the symbol must evaluate to `true`. 

+ For example:

```
true && true #=> true

true && false #=> false
```

For an `||` ("or") to evaluate to `true`, only **one** value on either side of the symbol must evaluate to true. 

+ For example:

```
false || true #=> true
```

Finally, a `!` ("not") reverses the logical state of its operand: if a condition is `true`, then `!` will make it `false`; if it is `false`, then `!` will make it `true`. 

+ For example:

```
!true #=> false

!false #=> true
```

##COMPARISON OPERATORS

To check if two values are equal, we use the comparison operator represented with `==` ("double-equal-sign"). If two values are equal, then the statement will return `true`. If they are not equal, then it will return `false`. 

+ For example:

```
1 == 1 #=> true

1 == 7 #=> false
```

**Top-tip**: The *comparison* operator `==` is distinct from the *assignment* operator `=` that is used to set a variable equal to a value. Mistaking these for each other is a common cause of unexpected behavior.

###MORE COMPARISON OPERATORS

Ruby is good at comparing things. For instance, it knows that `14` is larger than `3`. Let's see that in action.

```
14 > 3 #=> true
```

Here, `14` is larger than `3`, so Ruby evaluates this to `true`. Comparisons in Ruby always evaluate to `true` or `false`.

**The commonly used comparison operators are:**

Operator |	Operation
---------|-------------
`==`	| If the values of the two operands are *equal*, then the evaluation is `true`.
`!=	`| If the values of the two operands are *not equal*, then the evaluation is `true`.
`>`	| If the value of the left operand is *greater than* the value of the right operand, then the evaluation is `true`.
`<`	| If the value of the left operand is *less than* the value of the right operand, then the evaluation is `true`.
`>=`	| If the value of the left operand is *greater than or equal to* the value of the right operand, then the evaluation is `true`.
`<=`	| If the left operand is *less than or equal to* the value of the right operand, then the evaluation is `true`.

+ Ruby can compare a lot more than just numbers. It can also compare strings:

```
"yellow" == "yellow" #=>true
```

+ And variables with known values:

```
my_mood = "happy"

my_mood == "happy" #=> true
```

+ It can also compare variables against other variables:

```
easter_eggs = 16
ducklings = 3

easter_eggs > ducklings #=> true

ducklings >= easter_eggs #=> false

ducklings == easter_eggs #=> false

# if you call class on a variable, you can see if it's a
 string, an integer, etc.

ducklings.class #=> Integer
easter_eggs.class #=> Integer
ducklings.class == easter_eggs.class #=> true
```

Comparison operators are essential to developing logical flow.

##BOOLEAN ENUMERABLES
###Overview

When we are iterating over objects in a collection like with `#each` we generally don't care about the return values.

```
["Red", "Yellow", "Blue"].each do |color|
  puts "There are #{color.length} letters in #{color}"
end #=> ["Red", "Yellow", "Blue"]
```

If you run this code in IRB, you'll see:

```
001:0 > ["Red", "Yellow", "Blue"].each do |color|
?>        puts "There are #{color.length} letters in #{color}"
003:1 > end

There are 3 letters in Red
There are 6 letters in Yellow
There are 4 letters in Blue
=> ["Red", "Yellow", "Blue"]
```

You can see the block did what we intended it to do, it printed our output. You'll notice the last line also indicates that the `#each` method also returned a value. All expressions in ruby must return a value. When you use `#each` on a collection, the return value is always the original collection. Nothing you do inside the block you pass `#each` will ever change the return value. But that's not always the case. With other enumerator methods, the return value of the method is very much dependent on the block.

###`#all?`

Imagine wanting to know if all the numbers in an array are odd. You could use `each` with something like:

```
all_odd = true
[1,2,3].each do |number|
  if number.even? # Will evaluate to true for 1, false for 2, true for 1
    all_odd = false
  end
end
all_odd #=> false
```

That works, the end value of `all_odd` will be `false` because `1` and `3` flipped the `all_odd` variable to `false`. However, something so simple - checking if all the elements in this array are odd - isn't being expressed clearly. Worse than our code not expressing our intention is that our code requires us to maintain variable state, `all_odd`, which can easily lead to errors (say if some other piece of code accidentally changes that variable value).

Consider the following example using `#all?`:

```
all_odd = [1,3].all? do |number|
  number.odd? # Will evaluate to true for 1, true for 3
end #=> true
all_odd #=> true
```

The rule for the `#all?` enumerator is that the block passed to it must return true for every iteration for the entire `#all?` expression or method to return true. If we introduce an even number to the collection, the return value will change.

```
all_odd = [1,2,3].all? do |number|
  number.odd? # Will evaluate to true for 1, false for 2, true for 3
end #=> false
all_odd #=> false
```

That's the rule for `#all?` - every iteration, every loop of the block must return `true`. When the block encounters the value `2` for number, it will run the expression `2.odd?` which will return `false`. Because there was at least one iteration of the block that had a `false` return value, the entire `#all?` expression returns `false`.

###`#none?`

Imagine the opposite of `#all?`, a method `#none?`, where we are interested in none of the elements in a collection producing a true expression within the block passed to `#none?`.

```
[1,3].none?{|i| i.even?} #=> true
```

The entire expression `#none?` returns `true` because none of those numbers will produce a `true` expression when asked if they are even within the block. Compare the code above to the code required to test that condition using `#each`.

```
none_even = true
[1,3].each do |i|
  if i.even?
    none_even = false
  end
end #=> [1,3] because `#each` always returns the original collection
none_even #=> true
```

These high-level boolean enumerators like `#all?` and `#none?` are way cleaner for evaluating elements in a collection for `true`/`false` conditions.

The way `#none?` works is that no iteration of the block passed to `#none?` can create a true expression.

#any?

Sometimes you want to be a bit more forgiving than `#all?` or `#none?` and just ensure that at least one element in a collection will create a `true` expression within the block passed. `#any?` is perfect for this. The `#any?` enumerator will return `true` if at least one iteration of the block evaluates to `true`, but `false` if none of them do.

```
[1,2,100].any?{|i| i > 99} #=> true
```

The `#any?` expression above will return true because at least one element, `100`, will produce a `true` evaluation in the block.

###`#include?`

Whereas `#any?` is useful for evaluating the truthiness of the logic of a block, `#include?` is helpful if you'd like to merely compare actual contents of a known value.

`#include?` will return `true` if the given object exists in the element. If it doesn't find a match, it will return `false`.

```
the_numbers = [4,8,15,16,23,42]
the_numbers.include?(42)   #=> true
the_numbers.include?(6)   #=> false
```

The `#include?` expression first returns `true` because `the_numbers[5] == 42`. When it is run with `6`, it will evaluate to `false` since that item is not present in the array.

##SEARCH ENUMERABLES

###Overview

Every method in ruby must return a value. When we iterate or enumerate over a collection with `#each`, the return value is always the original collection. This is an example of a *static* return value, no matter what we do with `#each`, it will always return the same object that received the call to `#each`.

```
["Red", "Yellow", "Blue"].each do |color|
  puts "There are #{color.length} letters in #{color}"
end #=> ["Red", "Yellow", "Blue"]
```

Often we want to search for elements in a collection based on a condition. Imagine wanting to find all even numbers in a collection of numbers using `#each`.

```
matches = []
[1,2,3,4,5].each do |i|
  matches << i if i.even? # add i to the matches array if it
   is even
end #=> [1,2,3,4,5]
matches #=> [2,4]
```

Implementing a selection routine with a low-level enumerator like `#each` is costly in a few ways.

+ We have to maintain state with the local array matches.

+ Our block is complicated with conditional logic that can be implicit with a better enumerator.

+ Our code lacks intention and clear semantics. If we mean, `#find_all` or `#select`, why don't we just say that?

###`#select`

When you evoke `#select` on a collection, the return value will be a new array containing all the elements of the collection that cause the block passed to `#select` to return true. That means for each iteration, if the block evaluates to true, the element yielded to that iteration will be kept in the return value array.

```
[1,2,3,4,5].select do |number|
  number.even?
end #=> [2,4]
```

In the first iteration of the block above, number will be assigned the value `1`. Because `1.even?` will return false, `1` will not be in the return array for this call to `#select` (same for `3` and `5`). In the second iteration, number will be `2`. Because `2.even?` will return true, `2` will be in the return array (same for `4`).

You can see the clarity and expressiveness of this syntax in the short block form below.

```
[1,2,3,4,5].select{|i| i.odd?} #=> [1,3,5]

[1,2,3].select{|i| i.is_a?(String)} #=> []
```

Notice that if no element makes the block evaluate to `true`, an empty array is returned.

###`#detect` or `#find`

NOTE: detect and find are two names for the same method. For every example below we'll use detect, but you can use them interchangeably.

Whereas #select will return all elements from the original collection that cause the block to evaluate to true, #detect will only return the first element that makes the block true.

```
[1,2,3].detect{|i| i.odd?} #=> 1
```

As you can see, even though both `1` and `3` would cause the block to evaluate to `true`, because `1` is first in the array, it alone is returned.

```
[1,2,3,4].detect{|i| i.even?} #=> 2
[1,2,3,4].detect{|i| i.is_a?(String)} #=> nil
```

Notice also that `#detect` will always return a single object where `#select` will always return an array.

###`#reject`

`#reject` will return an array with the elements for which the block is `false`.

```
[1,2].reject{|i| i.even?} #=> [1]
```

###Conclusion

`#select`, `#detect`, and `#reject` are part of a family of search and filter type enumerators whose purpose is to help you refine a collection to only matching elements. They are way easier to manage then using lower-level methods like `#each` and create meaningful return values based on expressions in a block.

##WHAT IS FLOW CONTROL?

**A control flow construct is a language feature which disrupts the normal progression to the next statement and conditionally or unconditionally branches to another location in source code. –– Robert Klemme**

**In other words, control flow lets you tell your program what code to execute conditionally.** As humans, we actually enact flow control every day. For instance, if you are hungry, you will go and get a snack. Otherwise, you'll stay put and continue to read this awesome readme.

Control flow is an important part of Ruby programming and web development. In the context of a web application, for example, you can easily think of content or functionality on a website you've visited that is only available to a user if that user is logged in.

###IMPLEMENTING CONTROL FLOW

There are a number of ways to tell your program to conditionally execute certain code, the basic forms of which are:

+ `if`, `else`, and `elsif` statements,
+ `case` statements,
+ loops.

In this reading, we're going to discuss the first group of these "conditional" statements: `if`, `else`, and `elsif`.

###IF STATEMENTS
One of the most common ways to enact control flow is the `if` statement. Whatever block of code that follows the `if` statement will get evaluated—i.e. read and enacted by the computer. If this evaluation of the `if` statement results in `true`, then the code through to the associated end statement will run.

Let's look at a few examples:

```
if 5 > 2
  print "5 is greater than 2"
end
```

The code above will print `"5 is greater than 2"` because the if statement evaluates as `true`.

Meanwhile:

```
if 2 > 5
  puts "2 is greater than 5"
end
```

The code above will not print anything because the `if` statement evaluates as `false`.

So what if we want our program to print something else when the `if` condition evaluates as `false`?

###THE ELSE KEYWORD
To accomplish this, we can follow an `if` statement with an `else` statement. Take a look:

```
if false
   puts "This will never get printed because the above
     statement evaluates to false."
else
   puts "This will get printed!"
end
```

An `else` statement sets a "default" condition for when your `if` statement's conditional evaluates as `false`. Every condition that doesn't evaluate as `true` will instead pass through the `else` statement.

###FURTHER EXAMPLES

So far, we've seen if statements that rely on the explicit use of the `true` and `false` booleans. Let's look at some examples that require a little more thought.

**EXAMPLE 1**

```
if 6 + 3 == 9
  puts "Giraffes have no vocal cords."
end
# └── "Giraffes have no vocal cords."
```

The code above will print `Giraffes have no vocal cords`. Since `6 + 3` equals `9` (i.e. `9` is equal to `9`), the `if` statement's conditional evaluates as `true`.

**Top-tip**: Remember that the comparative operator `==` ("double-equals") is used to check equality. This is distinct from the assignment operator `=` ("single-equals"), which is used to set the value of a variable.

**EXAMPLE 2**

```
if 6 + 3 < 5
  puts "The hummingbird is the only animal that can fly
   backwards"
end
```

The code above will not print anything because `6 + 3`, which is equivalent to `9`, is not less than `5`, making the `if` statement's conditional evaluate as `false`.

**EXAMPLE 3**

```
dog = "satisfied"

if dog == "hungry"
  puts "Refilling food bowl."
else
  puts "Reading newspaper."
end

#  └── "Reading newspaper."
```

###ELSIF STATEMENTS

Sometimes, we want to control the flow of our program based on more than one condition. For example, if I am hungry, then I will get a snack. If I am thirsty, then I will get a drink of water. Otherwise, I will stay here and continue learning more about control flow.

We can add additional layers of complexity to our `if` and `else` statements by using the `elsif` keyword.

Let's add an `elsif` statement to Example 3 from above:

```
dog = "thirsty"

if dog == "hungry"
  puts "Refilling food bowl."
elsif dog == "thirsty"
  puts "Refilling water bowl."
else
  puts "Reading newspaper."
end

#  └── "Refilling water bowl."
```

We can cascade as many elsif statements as we wish, however `elsif` statements can only be used following an `if` statement, and must precede the associated `else` statement (if used).

```
dog = "cuddly"

if dog == "hungry"
  puts "Refilling food bowl."
elsif dog == "thirsty"
  puts "Refilling water bowl."
elsif dog == "playful"
  puts "Playing tug-of-war."
elsif dog == "cuddly"
  puts "Snuggling."
else
  puts "Reading newspaper."
end

#  └── "Snuggling."
```
##Refactoring Using the Ternary Operator

So far, our code leaves a little something to be desired. We are using an `if/else` statement that requires us to set a variable, `taken`, outside of the `if/else` statement, modify that variable and then return the variable at the end of the method. That's a lot of code to answer the simple question: "is this position taken?"

If you abstract out the task at hand, you might say "If a certain condition is met/if a certain condition evaluates to true, return one thing, otherwise, return something else." Ruby offers us a neat and efficient (not to mention elegant) way to accomplish such a task: **the ternary operator**. 

The ternary operator works like this: 

```
[if this statement is true] ? [return this thing] :
 [otherwise return this thing]
```

##LOOPS

###Introduction

There are a number of different ways to accomplish looping––the task of telling our program to do something a certain number of times. Here, we'll be looking at the most basic way to build a loop: using the `loop` keyword.

###The loop Keyword

The first looping construct that we'll discuss is `loop`. This is the simplest looping construct that we have in Ruby. It simply executes a block (the code that is between the `do` and `end` keywords). Try this in IRB in your Terminal:

```
loop do
  puts "I have found the Time Machine!"
end
```

This will output `I have found the Time Machine!` an infinite number of times in your Terminal. Use `Control`+`C` to break out of the loop in your terminal or just exit the session.

Loops start with the `loop` keyword and are opened by the following `do` and `end` block. All the code that goes inside the `do` and `end` is considered the loop's body or block; that's the code that will execute on repeat.

###Stopping Loops with Break and Counters

Infinite loops will break our program. The `loop` keyword alone will create an infinite loop. Generally, we want to loop only a certain amount of times. We can use the `break` keyword inside the body of the loop to exit or abort the loop and continue with the rest of our code. 

Consider:

```
loop do
  puts "You'll see this exactly once."
  break # Exit the Loop
end

puts "And the Loop is Done"
```

Our loop starts, it prints our message, and then the next line of code, `break` will actually end the loop. A loop that only runs once isn't useful. Neither is a loop that runs forever. So how do we actually build a useful loop, say, that runs exactly 10 times? Well first, we need a **counter**. Then we need to conditionally break out of the loop when the counter reaches 10. Then we need to increment the counter at every iteration (or execution of the loop).

```
counter = 0 # Start our counter at 0, we have never run 
  the loop
loop do # Start our loop
  # increment our counter by 1 and set it equal to the sum 
  of it's current value, plus 1. 
  
  counter = counter + 1

  # Do Something
  puts "Iteration #{counter} of the loop"

  if counter >= 10 # If our counter is 10 or more
    break # Stop the loop
  end
end
```

If you copy this to IRB you'll see:

```
Iteration 1 of the loop
Iteration 2 of the loop
Iteration 3 of the loop
Iteration 4 of the loop
Iteration 5 of the loop
Iteration 6 of the loop
Iteration 7 of the loop
Iteration 8 of the loop
Iteration 9 of the loop
Iteration 10 of the loop
```

This is a common basic loop. With this construct we can `break` a `loop` based on any condition, but the iteration count is a very common condition for stopping the loop.

###Advanced: The Add-And-Assignment (or Plus-Equals) Operator +=

Above, we use the addition operator (`+`) and the assignment operator `=` separately to reset the counter variable to the sum of it's old value, plus one, every time we repeat the loop. The add-and-assignment operator combines the functionality of the addition operator *and* the assignment operator. For example, let's say that our favorite cat Maru has just had a birthday:

```
adorable_cat = "Maru"
age = 7

# you've just had a birthday! add one year to your age:
age = 7 + 1
```

Let's take another look at our `age` variable and the operation of incrementing it by `1`:

```
age = 7
# age starts at 7 and will get incremented after the birthday
age = age + 1
age #=> 8
```

Here, we have one variable, `age` which starts at `7`. Then, we reassign `age` to hold the original value of `age` plus `1`. `age + 1` is evaluated first, returning `8`, and then we are assigning the result of that expression (everything on the right of `age =`, which again is `age + 1`, which just means `8`), as the new value for `age`. 

We can make this even more elegant by using the add-and-assignment operator `+=` instead:

```
age = 7
age += 1
age #=> 8
```

Here, `+=` serves the purpose of the above line: `age = age + 1`. It's simply condensing that action. It adds a numerical value (or other variable) to a numerical variable, and reassigns that variable to hold the sum of that variable's original value plus the added value (or other variable).

When we use `+=`, we call this action "incrementing". We are adding a new increment to a known value. Why is that useful? For looping.

Let's re-write our loop from earlier, this time using the `+= ` operator:

```
counter = 0

loop do 
  counter += 1
  puts "Iteration #{counter} of the loop"
  if counter >= 10 
    break
  end
end
```

###while

The `while` construct is a little different from the `loop` construct that we looked at earlier. The `while` construct will keep executing a block as long as a specific condition is `true`.

Remember our long and repetitiously-counting code that used if statements to count from `0` to `20`? Well, we can refactor that into simple, readable, short code with the `while` construct:

```
counter = 0
while counter < 20
  puts "The current number is less than 20."
  counter += 1
end
```

Think about the above code like this:

+ While it is true that the variable `counter` is set to a value that is less than `20`, execute the code in the block.

+ Inside the block, `puts` a phrase, and increment the counter by one.

+ Go back to the top! Check to see if the `counter` is less than `20`. If it is true that the value is less than `20`, go back into the block. Otherwise, break out of the loop and don't execute the code inside the loop.

We can achieve all of that with just a few lines of code utilizing a `while` construct.

**Examples**

Basic `while` Example: Hot Dog Eating Contest

Let's say you are a world famous competitive eater participating in the Coney Island Nathan's Hot Dog Eating Contest. You're kind of new to the competitive eating game though, so you only have the capacity for seven (7) hot dogs.

```
num_of_hotdogs_eaten = 0
# => 0 (return value)

while num_of_hotdogs_eaten < 7
  num_of_hotdogs_eaten += 1
  puts "You have now eaten #{num_of_hotdogs_eaten} hot dog(s)."
end
# => nil (return value)

puts "You ate a total of #{num_of_hotdogs_eaten} hot dogs!"
# => nil (return value)

# > "You have now eaten 1 hot dog(s)."
# > "You have now eaten 2 hot dog(s)."
# > "You have now eaten 3 hot dog(s)."
# > "You have now eaten 4 hot dog(s)."
# > "You have now eaten 5 hot dog(s)."
# > "You have now eaten 6 hot dog(s)."
# > "You have now eaten 7 hot dog(s)."

# > "You ate a total of 7 hot dogs!"
```

###until

**Until** is simply the inverse of a `while` loop. An `until` keyword will keep executing a block *until a specific condition is true*. In other words, the block of code following `until` will execute `while` the condition is false. One helpful way to think about it is to read `until` as "if not".

```
counter = 0
until counter == 20
  puts "The current number is less than 20."
  counter += 1
end
```

+ The counter once again starts at `0`. If it is not true that the counter is equal to `20`, the program will execute the code in the block.

+ Inside the block, we will `puts` a phrase and increment the counter by `1`.

+ Then, the program will go back to the top of the `until` loop and once again check to see if the counter is equal to `20`. If it is *not* true that the counter is equal to `20`, then the program will execute the code in the block. Otherwise, the program will break out of the loop.

##ITERATION & ABSTRACTION

###Iteration vs. Looping

In previous readings we discussed the five loop types, `loop`, `times`, `while`, `until`, and `for`. Now we're going to discuss the difference between looping and iteration. 

+ ***Looping*** occurs when you tell your program to do something a certain number of times. 

+ ***Iteration*** occurs when you have a collection of data (for example, an array), and you operate on each member of that collection.

+ ***Enumerable*** is Ruby's way of saying that we can get elements out of a collection (such as an array), one at a time.
	+ e·nu·mer·ate / Verb:

		Mention (a number of things) one by one.
Establish the number of.
An "enumerator", then, a the tool we can use to get each element out of a collection in this way.


For example, if I tell my program to print out the phrase "I love programming!" five times, that's *looping*. If I tell my program to enumerate over the array [1, 2, 3, 4, 5] and add 10 to each number, that's *iteration*.

###loop - The Least Abstract

Let's talk about the algorithm required to go through all the individual items in a set.

Imagine having a basket with ten (10) apples in it. What would you need to do to make sure that you took out all of the apples? You might think that it's enough to take an apple out of the basket one at a time. But that's not necessarily complete—at a certain point there will be no more apples in the basket; you will need to keep track of that or else you might never stop reaching in for more apples. The solution turns out to be a little more complex than it seemed at first; it might look like something like this:

+ Keep track of how many apples there are in the basket.

+ Keep track of how many apples you have taken out of the basket.

+ Start a loop.

+ If the count of apples you take out is less than the count of apples in the basket, take one out and increment the count of apples taken out by one.

+ If the count of apples taken out is NOT less than the count of apples originally in the basket, then break out of the loop.

This will ensure that we take out all the apples and never reach into the basket once it's been emptied of apples.

In Ruby, we might implement the above pseudocode into our code similar to this:

```
basket = ["apple 1","apple 2","apple 3","apple 4","apple 5",

"apple 6","apple 7","apple 8","apple 9","apple 10"]

apples_in_basket = basket.size # Step 1
apples_taken_out = 0 # Step 2

loop do # Step 3
    if apples_taken_out < apples_in_basket 
        # Step 4
        puts "Taking out #{basket[apples_taken_out]}"
        apples_taken_out += 1
    else
        # Step 5
        break
    end
end
```

So that's the least abstract implementation of the algorithm. All the details are there, every step is accounted for explicitly in the code. We won't change the algorithm, we'll just look at more abstract implementations.

###while - A Little More Abstract

The goal of abstraction is to remove details.

```
basket = ["apple 1","apple 2","apple 3","apple 4","apple 5","apple 6","apple 7","apple 8","apple 9","apple 10"]

apples_in_basket = basket.size # Step 1
apples_taken_out = 0 # Step 2

# Step 3 + 4
while apples_taken_out < apples_in_basket
    puts "Taking out #{basket[apples_taken_out]}"
    apples_taken_out += 1
end

```

What we did here first was combine to steps 3 and 4 into a `while` loop—initializing a cycle of behavior based upon a condition, which is what the word `while` means both in Ruby and in English. Abstraction didn't make our code less clear, it rather made our code "absolutely precise". Brevity for the sake of brevity is silly, but our goal is to always express ourselves as clearly and honestly as possible. Because our loop is conditional from the start by using the `while` loop construct, we don't need to explicitly break out of it; this makes step 5 implicit.

###each - The Most Abstract

Being abstract is something profoundly different from being vague.... The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.

— Edsger Dijkstra

```
basket = ["apple 1","apple 2","apple 3","apple 4","apple 5","apple 6","apple 7","apple 8","apple 9","apple 10"]

# Step 1,2,3,4,5
basket.each do |apple|
    puts "Taking out #{apple}"
end
```

Here we see the full power of the Ruby iterators. To quote Kent Beck, "you don't use 3-4 lines to express iteration, you use one word." If you mean each apple, just say *each apple*. All the details of the algorithm are removed and replaced with the intention of our code, not the implementation of the algorithm.

##Looping vs. Iteration

+ **Looping** is a programming construct that allows you to tell your program to do something a certain number of times, or until a certain condition is met. It is a mechanism to repeat a selection of code.

+ **Iteration**, on the other hand, is a way to operate on a collection object, like an array, and do something with **each** element in that collection.

Let's say that we are writing a program to annoy our little brother. We don't want to annoy him too much though, or else we might get grounded. So, our program, when it runs, will `#puts` "Stop hitting yourself!" seven times, and then stop. For a task like this, in which we need to perform a task a certain, discrete number of times, we would use a loop.

Let's take a look:

```
7.times do
  puts "Stop hitting yourself!"
end
```

What if we want to output the phrase only until our little brother calls out "Mommmm!!"? We can stick with a loop construct like while:

```
input = ""
while input != "Mommmm!!"
  puts "Stop hitting yourself!"
  input = gets.chomp
end
```

However, what if we have three little brothers: Tom, Tim and Jim, and we want to output "Stop hitting yourself, #{little brother's name}!" once for each brother? Let's try that out using a loop with the `while` construct:

```
brothers = ["Tom", "Tim", "Jim"]

count = 0
while count <= brothers.length-1
  puts "Stop hitting yourself #{brothers[count]}!"
  count += 1
end
```

In order to output a simple phrase using each brother's name from our collection with a while loop we need to:

+ Establish a counter

+ Set the condition for the while loop

+ Increment the counter at the bottom of the loop

+ Read data out of the array by index using the counter.

That's a lot of code to accomplish such a simple task. In fact, a loop isn't a good tool for this job. Since we are now operating on a collection of data and seeking to *do something* with each element of that collection, we want to use an **iterator**.

Iterators are methods that you can call on a collection, like an array, to loop over each member of that collection and do something to or with that member of the collection. Let's take a look in the next section.

###Using #each

The `#each` method is a prime example of an iterator. Here's a boilerplate example of it's usage:

```
primary_colors = ["Red", "Yellow", "Blue"]
primary_colors.each do |color|
  puts "Primary Color #{color} is #{color.length} letters long."
end
```

`#each` is called on the collection `primary_colors`, which is an array containing 3 individual strings.

A block is passed to `#each`, opened by the code that starts with `do` and closed by the preceding `end`. Every `do` needs a closing `end`.

```
primary_colors = ["Red", "Yellow", "Blue"]
primary_colors.each do |color| # do begins a block
  # the lines between the do/end are the block's body
  puts "Primary Color #{color} is #{color.length} letters long."
end # end terminates the block
```

The output from this code is:

```
Primary Color Red is 3 letters long.
Primary Color Yellow is 6 letters long.
Primary Color Blue is 4 letters long.
```

We can see that the block passed to each is executed once for each element in the original collection. If there were 5 colors in `primary_colors`, the block would have run 5 times. We call each run, each execution, of the block passed to the iterator (`#each` in this case), an **iteration**. It's a word used to refer to each 'step', or each 'execution', of a block. **An iteration is the singular execution of a sequence of code (that we call a block) within a loop.**

When we iterate over a collection of elements using `#each` (and also in other iterators and enumerables we'll soon learn about), the iterator `#each` yields each element one at a time to every iteration via a variable declared with the opening of the block.

After the opening do of our code above, we see `|color|`. `|` is called a **pipe**. After `do`, we declare a local variable color by enclosing it in `| |` pipes. This variable's value is automatically assigned the element from the array for the current iteration. So on the first iteration of the each above, the variable color would be equal to `"Red"`. But on the next iteration of the block, `color` will be reassigned the value of the next element in the `primary_colors` array, `"Yellow"`.

Let's take a closer look at some of these concepts.

###WHAT IS A BLOCK?

A block is a chunk of code between braces, `{ }` or between `do/end` keywords that you can pass to a method almost exactly like you can pass an argument to a method. There are some methods, like iterator methods, that can be called with a block, i.e. accompanied by a block denoted with `{ }` or `do/end`. Such a method would run and pass, or yield, data to the code in the block for that code to operate on or do something with.

Blocks are part of what make the Ruby language special, powerful, and loved.

###WHAT ARE THE | |?

Those are called "pipes". When invoking an iterator like `#each`, the variable name inside the pipes acts as an argument that is being passed into the block. The iterator will pass, or yield, each element of the collection on which it is called to the block. Each element, as it gets passed into the block, will be equal to the variable name inside the pipes. Think of it like this:

+ Call, or run, the code in the block once for each element of the collection.

+ Pass a single element of the collection into the block every time the code in the block is called, or run. Start with the first element in the collection, and then move on to the second element, then the third, etc.

+ Every time you call the code in the block and pass in an element from the collection, set the variable name from between the pipes equal to that element.

This is exactly what happens when you define a method to accept an argument and then call that method with a real argument:

```
def hi_there(name)
  puts "Hi, #{name}"
end

hi_there("Sophie") # > "Hi, Sophie"
# => nil 
```

Think of the variable between the pipes like the `name` variable we are using to define our argument.

The variable `name` inside the pipes is more or less arbitrary. For example:

```
brothers = ["Tim", "Tom", "Jim"]
brothers.each do |brother|
  puts "Stop hitting yourself #{brother}!"
end
```

Will output the same thing as:

```
brothers = ["Tim", "Tom", "Jim"]
brothers.each do |hippo|
  puts "Stop hitting yourself #{hippo}!"
end
```

Which is:

```
Stop hitting yourself Tim!
Stop hitting yourself Tom!
Stop hitting yourself Jim!
```

We should, however, be reasonable and sensical when we name our variables. If your collection is called `brothers`, name the variable between the pipes `brother`. If you collection is called `apples`, name your variable `apple`.

###A CLOSER LOOK

Let's revisit our example from above and break it down, step by step:

```
brothers = ["Tim", "Tom", "Jim"]
brothers.each do |brother|
  puts "Stop hitting yourself #{brother}!"
end
```

Here, the `#each` method takes each element of the `brothers` array, one at a time, and passes, or yields, it into the block of code between the `do/end` keywords. It makes each element of the array available to the block by assigning it to the variable `brother`. It does so by placing that variable `name` in between the pipes `| |`.

In summary, `#each` yields each item of the collection on which it is called to the block with which it is called. It keeps track of which element of the collection it is manipulating as it moves through the collection. During the first step of the iteration, `#each` will yield the first array element to the block. At that point in time, inside the block, `brother` will equal `"Tim"`. During the second step of the iteration, `brother` will equal `"Tom"` and so on.

Iterators like `#each` are smart – they don't need a separate counter variable and manual incrementation of that variable to know how many times to do something. **They use the number of items in the collection on which they are called to determine how many times they will do something.**

Let's set a `counter` variable and manually increment it in order to see the `#each` method in action:

```
brothers = ["Tim", "Tom", "Jim"]
counter = 1
brothers.each do |brother|
  puts "This is loop number #{counter}"
  puts "Stop hitting yourself #{brother}!"
  counter += 1
end
```

Copy and paste the above code into IRB. You should see this output:

```
This is loop number 1
Stop hitting yourself Tim!
This is loop number 2
Stop hitting yourself Tom!
This is loop number 3
Stop hitting yourself Jim!
#=> ["Tim", "Tom", "Jim"]
```

See that, during loop number 1, the string `"Tim"` was yielded to the block and the variable name `brother`, when interpolated into the string we `#puts`ed out, was set equal to `"Tim"`. During loop number 2, the same thing happened with `"Tom"`, and during loop number 3, the same thing happened with `"Jim"`. There was no loop number four because the `#each` iterator operated on each member of the array on which it was called and then stopped.

###A NOTE ON RETURN VALUES

Different iterators have different return values. Notice that the return value of the call to `#each` above returned `["Tim", "Tom", "Jim"]` – the original array. The `#each` method will always return the original collection on which it was called.

`THE { } SYNTAX`

Another way of establishing a code block that you may encounter is to use curly brackets, `{ }`, instead of the `do/end` keywords. Let's take a look:

```
brothers = ["Tim", "Tom", "Jim"]
brothers.each{|brother| puts "Stop hitting yourself #{brother}!"}
```

It is appropriate to use the `{ }` syntax when the code in the block is short and can fit on one line.

###Conclusion

Both loops and iterators are powerful tools in Ruby, but they're not right for every job. Loops are useful when you need to tell your program to do something a certain number of times or to do something based on a certain condition. Iterators are useful for operating on a collection of objects, and even performing complex operations on the members of that collection. Because iterators are called with blocks, it's easy to carry out complex logic or tasks using each individual member of a collection of objects.

##HASHES

Hashes also store objects in Ruby. However, they differ from arrays in that they function like dictionaries. Instead of a simple comma separated list, hashes are composed of key/value pairs. Each key points to a specific value––just like a word and a definition in a regular dictionary.

Hashes look like this:

~~~
{"i'm a key" => "i'm a value!", "key2" => "value2"}
~~~

The curly brackets denote the hash and this particular hash has two key/value pairs.

###CREATING HASHES
Hashes can be created with **literal constructors** and **class constructors**.

+ **The Literal Constructor**: You can create a hash by simply writing key/value pairs enclosed in curly braces.

+ **The Class Constructor**: Or, you can use the `Hash.new` syntax, which would create an empty hash, `{}`.

##Puts & Print

The puts (short for "out*put s*tring") and print commands are both used to display in the console the results of evaluating Ruby code. The primary difference between them is that puts adds a newline after executing, and print does not.

```
3.times { print "Hello!" }
# > Hello!Hello!Hello!

3.times { puts "Hello!" }
# > Hello!
# > Hello!
# > Hello!
```

By default, Ruby doesn't display any output. The methods puts and print are a great way to explicitly tell the program to display specific information. Without these printing methods, Ruby will read the line, but not print anything out.

###RETURNING VALUES

What methods like puts and print allows us to output to the console are different from Ruby's concept of a return value.

A return value is the data returned to the program by the execution of a method, the assignment of a variable, actually...

Everything in Ruby has a return value!

For instance:


Code  |   Return Value
------|---------------
`"Hello world"` |	`"Hello world"`
`6 + 3`	| `9`
`president = "Obama"`	| `"Obama"`
`total = 6 + 3` | 	`9`
`puts "hello world"`	| `nil`
`print "hello world"`	| `nil`


You may notice that the `puts` and `print` methods, when run in IRB, print values on the screen and then display a line like this: `=> nil`. This is because `puts` and `print` may print the value you want, but instead of returning that value, they return `nil`.

###RETURN VALUES OF METHODS
Methods are like vending machines. When you use a vending machine you just put in two arguments, the number (C7) and your money. We already know how to use arguments, but then your vending machine might do two things. One, it will make a noise saying that everything worked, beep beep. Then it gives you the soda. The soda is the return type. But those beeps? Are you able to do anything with them? Nope! That's like puts: it just tells you stuff and then goes into the ether! Gone forever.

Every method in Ruby returns a value by default, even custom ones. This returned value will be the value of the last statement.

For example, let's look at this method called `restaurant`:

```
def restaurant
  restaurant_name = "Guy's American Kitchen & Bar"
  cuisine = "american"
  motto = "Welcome to Flavor Town!"
end
```
The return value of the restaurant method is `"Welcome to Flavor Town!"` because that was the last statement evaluated.

Say you're the best chef in the world, Guy Fieri. To make a method that just prints your name and returns `nil`, you could write:

```
def print_name
  puts "Guy Fieri"
end
```

To write a method that returns your name but doesn't print anything, you could write:

```
def return_name
  "Guy Fieri"
end
```

To both print and return your name, you could write:

```
def print_and_return_name
  puts "Guy Fieri"
  "Guy Fieri"
end
```

If you accidentally switched the order of the lines inside the method:

```
def broken_print_and_return_name
  "Guy Fieri"
  puts "Guy Fieri"
end
```

The method would instead print `"Guy Fieri"` and return `nil`. This is because the last line that was evaluated was `puts ...` and the return value of a `puts`, as seen in the table above is always `nil`.

###THE RETURN KEYWORD

There is one other way to return a value from a method and that is to use the `return` keyword.

Let's take a look:

```
def stylish_chef
  best_hairstyle = "Guy Fieri"
  return "Martha Stewart"
  "Guy Fieri"
end
```

You may have expected the return value to be "Guy Fieri". However, the return value of the above method is actually `=> Martha Stewart`!

The return keyword will disrupt the execution of your method. If you employ it, your method will return whatever you have explicitly told it to (in this case, `"Martha Stewart"`), and terminate.

The explicit use of the `return` keyword is generally avoided by many Rubyists.

###WHY RETURN VALUES MATTER
Return values are how different parts of your program communicate with one another. You don't have to worry too much about this for now, but as you start to build more complicated programs, you'll find that the return value of one method might be operated on by a subsequent method.

Let's look at a very basic example. Earlier, in IRB, we set a variable `total` equal to the return value of adding `6 + 3`. If you've left IRB, drop back in and re-create your `total` variable as the sum of `6 + 3`.

On the next line, execute `total + 17`. You should see a return value of `=> 26`. Thus, the return value of one operation (`6 + 3`) was used to execute further operations (the addition of `17`).

As we've just done, you'll find that we will often store return values in variables so that we can use them later.

##String Methods 
1. Puts
 + a. .to_s, .to_i, .to_f
 + b. .reverse : reverses order
 + c. .length : # of characters (not letters, so counts spaces too)
 + d. .upcase : changes every lowercase to uppercase
 + e. .downcase : change every uppercase to lowercase
 + f. .swapcase : swaps cases
 + g. .capitalize : capitalized first character!! not first letter. Downcases everything else. 
 + h. str.center(how wide you want the centered string to be)
 + Ex: line_width= 50 (so that you can easily go back and change one variable instead of all the lines) 
     str.center(line_width)
 i. str.ljust( line_width), str.rjust(line_width)

2. gets(.chomp)

##Math
 + a. ' ** ' : exponent
   
   + 5 ** 2= 25
   + 5 ** 0.5= 5^0.5
   
 + b. **'%'** : modulus (gets you the remainder of operation)
    
    + 7%3= 1 (7/3= 2 r1)
    
 + c. **'.abs'** : absolute value
 + d. **'rand( )'** : random number generator  
     + srand : seed. To repeat the same random numbers. 
 + e. **'Math ::'** : like a scientific calc. Treat like a variable. 
     + 'Math :: PI' : constant, doesn't vary. 
    + 'puts (Math.cos(Math::PI/3))': 0.5