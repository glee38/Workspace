#Associations & Rails

##Activerecord Associations Review
ActiveRecord associations are an iconic Rails feature. They allow developers to work with complex networks of related models without having to write a single line of SQL--as long as all of the names line up!

####OBJECTIVES
After this lesson, you will be able to...

1. Create the correct foreign keys for associations.
2. Use the correct association macros to apply an ActiveRecord association.
3. List the methods that are added by the association macros.
4. Use `build` and `create` correctly to instantiate associated data. `post.build_author` and `author.posts.build`
5. Add associated data to a collection association (push objects onto a `has_many` association, `@category.posts << post`).
6. Identify the SQL generated by various association methods.
7. Construct a join model and table.
8. Use a `has_many :through` with a join model.
9. Manipulate associated data from a `has_many :through` including creating the association from the join model directly `PostTag.new(:post => post, :tag => tag)`

####FOREIGN KEYS
It all starts in the database. **Foreign keys** are columns that refer to the primary key of another table. Conventionally, foreign keys in ActiveRecord are comprised of the name of the model you're referencing, and `_id`. So for example if the foreign key was for a `posts` table it would be `post_id`.

Like any other column, foreign keys are accessible through instance methods of the same name. For example, a migration that looks like this:

```ruby
class AddAuthorIdToPosts < ActiveRecord::Migration
  def change
    change_table :posts do |t|
      t.integer :author_id
    end
  end
end
```

Would mean you could find a post's author with the following ActiveRecord query:

```ruby
Author.find(@post.author_id)
```

Which is equivalent to the SQL:

```
SELECT * FROM authors WHERE id = #{@post.author_id}
```

And you could lookup an author's posts like this:

```ruby
Post.where("author_id = ?", @author.id)
```

Which is equivalent to the SQL:

```
SELECT * FROM posts WHERE author_id = #{@author.id}
```

This is all great, but Rails is always looking for ways to save us keystrokes.

####MANY-TO-ONE RELATIONSHIPS
By using ActiveRecord's macro-style association class methods, we can add some convenient instance methods to our models.

The most common relationship is **many-to-one**, and it is declared in ActiveRecord with `belongs_to` and `has_many`.

#####`BELONGS_TO`
Each `Post` is associated with **one** `Author`.

```ruby
class Post < ActiveRecord::Base
  belongs_to :author
end
```

We now have access to some new instance methods, like `author`. This will return the actual `author` object that is attached to that `@post`.

```ruby
@post.author_id = 5
@post.author #=> #<Author id=5>
```

#####`HAS_MANY`
In the opposite direction, each `Author` might have zero, one, or many Posts. We haven't changed the schema of the `authors` table at all; ActiveRecord is just going to use `posts.author_id` to do all of the lookups.

```ruby
class Author < ActiveRecord::Base
  has_many :posts
end
```

Now we can look up an author's posts just as easily:

```ruby
@author.posts #=> [#<Post id=3>, #<Post id=8>]
```

Remember, ActiveRecord uses its [Inflector](http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html) to switch between the singular and plural forms of your models.

Name | Data
-----|-----
Model | `Author`
Table | `authors`
Foreign Key | `author_id`
`belongs_to` | `:author`
`has_many` | `:authors`

Like many other ActiveRecord class methods, the symbol you pass determines the name of the instance method that will be defined. So `belongs_to :author` will give you `@post.author`, and `has_many :posts` will give you `@author.posts`.

####CONVENIENCE BUILDERS
#####BUILDING A NEW ITEM IN A COLLECTION
If you want to add a new post for an author, you might start this way:

```ruby
new_post = Post.new(author_id: @author.id, title: "Web Development for Cats")
new_post.save
```

But the association macros save the day again, allowing this instead:

```ruby
new_post = @author.posts.build(title: "Web Development for Cats")
new_post.save
```

This will return a new `post` object with the `author_id` already set for you! We use this one as much as possible because it's just easier. `build` works just like `new`. So the instance that is returned isn't quite saved to the database just yet. You'll need to `#save` the instance when you want it to be persisted to the database.

#####SETTING A SINGULAR ASSOCIATION
It's a little bit less intuitive for singular associations. Remember a post `belongs_to` an author. The verbose way of doing this would be like so:

```ruby
@post.author = Author.new(name: "Leeroy Jenkins") 
```

In the previous section, `@author.posts` always exists, even if it's an empty array. Here, `@post.author` is `nil` until the author is defined, so ActiveRecord can't give us something like `@post.author.build`. Instead, it prepends the attribute with `build_` and `create_`. The `create_` will persist to the database for you.

```ruby
new_author = @post.build_author(name: "Leeroy Jenkins")
```

Remember! you need to save your new `author` with `#save`.
These methods are also documented in the [Rails Associations Guide](http://guides.rubyonrails.org/association_basics.html).

#####COLLECTION CONVENIENCE
If you add an existing object to a collection association, ActiveRecord will conveniently take care of setting the foreign key for you:

```ruby
@author = Author.find_by(name: "Leeroy Jenkins")
@author.posts
#=> []
@post = Post.new(title: "Web Development for Cats")
@post.author
#=> nil
@author.posts << @post
@post.author
#=> #<Author @name="Leeroy Jenkins">
```

####ONE-TO-ONE RELATIONSHIPS
Profiles can get pretty complex, so in large applications, it can be a good idea to give them their own model. In this case:

+ Every author would have one, and only one, profile
+ Every profile would have one, and only one, author.

`belongs_to` makes another appearance in this relationship, but instead of `has_many`, the other model is declared with `has_one`.

If you're not sure which model should be declared with which macro, it's usually a safe bet to put `belongs_to` on whichever model has the foreign key column in its database table.

####MANY-TO-MANY RELATIONSHIPS AND JOIN TABLES
Each author has many posts, each post has one author.

The universe is in balance. We're programmers, so this really disturbs us. Let's shake things up and think about tags.

+ One-to-One doesn't work because a post can have multiple tags.
+ Many-to-One doesn't work because a tag can appear on multiple posts.

Because there is no "owner" model in this relationship, there's also no right place to put the foreign key column.

Enter the join table:

tag_id | post_id
-------|--------
1 | 1
2 | 1
1 | 5

This join table depicts two tags (1 and 2) and two posts (1 and 5). Post 1 has both tags, while Post 5 has only one.

Mercifully, ActiveRecord has a migration method for doing exactly this.

```ruby
create_join_table :posts, :tags
```

This will create a table called `posts_tags`.

#####`HAS_MANY :THROUGH`
To work with the join table, both our `Post` and our `Tag` model will `have_many` `post_tags`. But! We still need to associate `Post` and `Tag` themselves. I would like to do something like `@my_post.tags` right? That's where `has_many :through` comes in.

To do this requires a bit of focus. But you can do it! First of all, our `Post` and our `Tag` model will `has_many` `:posts_tags`.

```ruby
class Post
  has_many :posts_tags
end
 
class PostsTag
  belongs_to :post
  belongs_to :tag
end
 
class Tag
  has_many :posts_tags
end
```

So now we can run code like `@post.posts_tags` to get all the join entries. This is kinda sorta what we want. What we really want is to be able to do `@post.tags`. So! We need one more `has_many` relationship to make the link between tags and posts. This is the `has_many :through`. In English, my `Post` has many `Tags` through the `posts_tags` model. So let's write that:

```ruby
class Post
  has_many :posts_tags
  has_many :tags, through: :posts_tags
end
 
class PostsTag
  belongs_to :post
  belongs_to :tag
end
 
class Tag
  has_many :posts_tags
  has_many :posts, through: :posts_tags
end
```

Now! You can do `@post.tags` and everything should work :)

####SUMMARY
For every relationship, there is a foreign key somewhere. Foreign keys correspond to the `belongs_to` macro on the model.

One-to-one and many-to-one relationships only require a single foreign key, on the "subordinate" or "owned" model. The other model declares its relationship with `has_one` or `has_many`, respectively.

Many-to-many relationships require a join table, with a foreign key for both models. These are joined using `has_many :through`.

You can see the entire [list of class methods](http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html) in the Rails API docs.

##ActiveRecord Lifecycle Methods
####CALLBACKS
Now that you are integrating ActiveRecord into Rails, we must first have a quick discussion about how developers can control the "lifecycle" of our object. This means that it can be nice to inject our code every time ActiveRecord does something to our model. There are a ton of different places we can inject our code. In this reading we are going to discuss the most common ones. Before we begin, some quick terminology. Everything we cover here are called "Active Record Lifecycle Callbacks". Many people just call them callbacks. It's a bit shorter.

Take a look at the blog app that is included. It's pretty simple. We have a `Post` model and a few views. The `Post` `belongs_to` an `Author`. Also in the `Post` model you'll notice a validation to make sure that post titles are in title case. Title case means every word starts with a capital letter.

While this validation is great, there is a method provided by Rails called `#titlecase` that will do this for us. I still want this validation, but let's make it so that just automatically before we save the record it runs `#titlecase`. What a convenience we are providing to our users! We are going to use our first callback, `before_save`. We use this similar to how you use `has_many` or `validates`. They are at the top of your model files. First let's write our method to actually run the `#titlecase` method.

```ruby
# post.rb
 
  def make_title_case
    self.title = self.title.titlecase
  end
```

Ok, now we want to run this whenever someone tries to save to the database. This is where the `before_save` comes:

```ruby
class Post < ActiveRecord::Base
 
  belongs_to :author
  validate :is_title_case 
 
# New Code!!
  before_save :make_title_case 
 
  private
 
  def is_title_case
    if title.split.any?{|w|w[0].upcase != w[0]}
      errors.add(:title, "Title must be in title case")
    end
  end
 
  def make_title_case
    self.title = self.title.titlecase
  end
end
```

This shouldn't look too alien! Pretty much whenever you persist to the database (so #save and #create) this code will get run. Let's open up the console (rails c) and test it out:

```ruby
p = Post.create(title: "testing")
#   (0.1ms)  begin transaction
#   (0.1ms)  rollback transaction
# => #<Post id: nil, title: "testing", description: nil, created_at: nil, updated_at: nil, post_status: nil, author_id: nil>
```

Wait! There was no `INSERT` SQL command issued. In fact, we see the `rollback transaction` line. That means that it didn't actually save to the database. If we do `p.valid?` right now it will return `false`. That's not right. We automatically title case things. The validation should pass! Then after reading much documentation, it turns out that the `before_save` is called **after** validation occurs. So it Rails goes `is valid?` Nope! Stop!. It never makes it to `before_save`. Let's change our callback to the `before_validation` callback. This one happens **before** validation. That means that first our `before_validation` code works, which title cases the title, *then* the validation runs, which passes! Here is the final code:

```ruby
class Post < ActiveRecord::Base
 
  belongs_to :author
  validate :is_title_case 
 
# New Code!!
  before_validation :make_title_case 
 
  private
 
  def is_title_case
    if title.split.any?{|w|w[0].upcase != w[0]}
      errors.add(:title, "Title must be in title case")
    end
  end
 
  def make_title_case
    self.title = self.title.titlecase
  end
end
```

Here is a rule of thumb: **Whenever you are modifying an attribute of the model, use `before_validation`. If you are doing some other action, then use `before_save`.**

####BEFORE SAVE
Now let's do something that belongs in the `before_save`. We use `before_save` for actions that need to occur that aren't modifying the model itself. For example, whenever you save to the database, let's send an email to the Author alerting them that the post was just saved!

This is a perfect `before_save` action. It doesn't modify the model so there is no validation weirdness, and we don't want to email the user if the Post is invalid. That would be just mean! So if you had some method called `email_author_about_post` you would modify your `Post` model to look like this:

```ruby
class Post < ActiveRecord::Base
 
  belongs_to :author
  validate :is_title_case 
 
  before_validation :make_title_case 
 
# New Code!!
  before_save :email_author_about_post
 
  private
 
  def is_title_case
    if title.split.any?{|w|w[0].upcase != w[0]}
      errors.add(:title, "Title must be in title case")
    end
  end
 
  def make_title_case
    self.title = self.title.titlecase
  end
end
```

####BEFORE CREATE
Before you move on, let's cover one last callback that is super useful. This one is called `before_create`. `before_create` is very close to `before_save` with one major difference: it only gets called when a model is created for the first time. This means not every time the object is persisted, just when it is **new**.

For more information on all of the callback available to you, check out [this amazing rails guide](http://guides.rubyonrails.org/active_record_callbacks.html).

##Forms and Basic Association
####OBJECTIVES
1. Populate select options based on association options.
2. Assign a foreign key based on an input box value directly through mass assignment. (`post[category_id]`)
3. Define a belongs_to association writer.
4. Build a form field that will delegate to a belongs_to association writer. (`post#category_name=`) through controller mass assignment.
5. Define a has_many association writer.
6. Build a form field that will delegate to a has_many association writer. (`category#post_ids=`) through controller mass assignment.

####THE PROBLEM
Let's say we have a simple blogging system. Our models are Post and Category. A Post `belongs_to` a Category.

```ruby
# app/models/post.rb
class Post < ActiveRecord::Base
  belongs_to :category
end
 
# app/models/category.rb
class Category < ActiveRecord::Base
  has_many :posts
end
```

Now we need to build the functionality for a user to create a Post. We're going to need a form for the Post's content, and some way to represent what Category the Post belongs to.

####USING THE CATEGORY ID
As a first pass, we might build a form like this:

```ruby
<%= form_for @post do |f| %>
  <%= f.label :category_id, :category %><%= f.text_field :category_id %>
  <%= f.text_field :content %>
<% end %>
```

This will work if we wire up our `PostsController` with the right parameters:

```ruby
class PostsController < ApplicationController
  def create
    Post.create(post_params)
  end
 
  private
 
  def post_params
    params.require(:post).permit(:category_id, :content)
  end
end
```

But as a user experience, this is miserable. I have to know the id of the category I want to use. As a user, it is very unlikely that I know this or want to.

We could rewrite our controller to accept a `category_name` instead of an id:

```ruby
class PostsController < ApplicationController
  def create
    category = Category.find_or_create_by(name: params[:category_name])
    Post.create(content: params[:content], category: category)
  end
end
```

But we'll have to do this anywhere we want to set the category for a Post. When we're setting a Post's categories, the one thing we know we have is a Post object. What if we could move this logic to the model?

Specifically, what if we gave the Post model a `category_name` attribute?

####DEFINING A CUSTOM SETTER (CONVENIENCE ATTRIBUTES ON MODELS)
Since our ActiveRecord models are still just Ruby classes, we can define our own setter methods:

```ruby
# app/models/post.rb
class Post < ActiveRecord::Base
   def category_name=(name)
     self.category = Category.find_or_create_by(name: name)
   end
end
```

The setter method `#category_name=` is called whenever a `Post` is initialized with a `category_name` field. We can expand `Post.create(post_params)` to:

```ruby
Post.create({
  post: {
    category_name: params[:post][:category_name],
    content: params[:post][:content]
  }
})
```

so that you can see that `#category_name=` will indeed be called. Since we have defined this setter ourselves, `Post.create` does not try to fall back to setting `category_name` through ActiveRecord. You can think of `#category_name=` as intercepting the call to the database and instead shadowing the attribute `category_name` by, one, making sure the `Category` exists; and, two, providing it in-memory for the `Post` model. We sometimes call these in-memory attributes "virtuals".

Now we can set `category_name` on a post. We can do it when creating a post too, so our controller becomes quite simple again:

```ruby
class PostsController < ApplicationController
  def create
    Post.create(post_params)
  end
 
  private
 
  def post_params
    params.require(:post).permit(:category_name, :content)
  end
end
```

Notice the difference—we're now accepting a category name, rather than a category id. Even though you don't have an ActiveRecord field for `category_name`, because there is a key in the `post_params` hash for `category_name` it still calls the `category_name=` method.

We can change the view as well now:

```ruby
<%= form_for @post do |f| %>
  <%= f.label :category_name %>
  <%= f.text_field :category_name %>
  <%= f.text_field :content %>
<% end %>
```

Now the user can enter a category by name (instead of needing to look up its id), and we handle finding or creating the `Category` in the black box of the server. This results in a much friendlier experience for the user.

####SELECTING FROM EXISTING CATEGORIES
If we want to let the user pick from existing categories, we can use a [collection_select](http://apidock.com/rails/ActionView/Helpers/FormOptionsHelper/collection_select) helper to render a `<select>` tag:

```ruby
<%= form_for @post do |f| %>
  <%= f.collection_select :category, Category.all, :id, :name %>
  <%= f.text_field :content %>
<% end %>
```

This will create a drop down selection input where the user can pick a category.

However, we've lost the ability for users to create their own categories.

That might be what you want. For example, the content management system for a magazine would probably want to enforce that the category of an article is one of the sections actually printed in the magazine.

In this case, I think we want to give users the flexibility to either create a new category, or pick an existing one. What we want is autocompletion, which we can get with a [`datalist`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist):

```html
<%= form_for @post do |f| %>
  <%= f.text_field :category, list: "categories_autocomplete" %>
  <datalist id="categories_autocomplete">
    <%= Category.all.each do |category| %>
      <option value="<%= category.name %>">
    <% end %>
  </datalist>
  <textarea name="post[content]"></textarea>
<% end %>
```

`datalist` is a new element in the HTML5 spec that allows for easy autocomplete. Check below in [Resources](https://learn.co/tracks/full-stack-web-development/rails/associations-and-rails/forms-and-basic-association#resources) for further reading.

####UPDATING MULTIPLE ROWS
Let's think about the reverse association. Categories have many posts.

```ruby
# app/models/category.rb
class Category < ActiveRecord::Base
  has_many :posts
end
```

Given a category, how do we let a user specify many different posts to categorize? We can't do it with just one `<select>` because we can have many posts in that category.

####USING ARRAY PARAMETERS
Rails uses a [naming convention](http://guides.rubyonrails.org/v3.2.13/form_helpers.html#understanding-parameter-naming-conventions) to let you submit an array of values to a controller.

If you put this in a view, it looks like this.

```html
<%= form_for @category do |f| %>
  <input name="post_ids[]">
  <input name="post_ids[]">
  <input name="post_ids[]">
<% end %>
```

When the form is submitted, your controller will have access to a `post_ids` param, which will be an array of strings.

We can write a setter method for this, just like we did for `category_name`:

```ruby
# app/models/category.rb
class Category < ActiveRecord::Base
   def post_ids=(ids)
     ids.each do |id|
       post = Post.find(id)
       self.posts << post
     end
   end
end
```

Now we can use the same wiring in the controller to set `post_ids` from `params`:

```ruby
# app/controllers/categories_controller.rb
class CategoriesController < ApplicationController
  def create
    Category.create(category_params)
  end
 
  private
 
  def category_params
    params.require(:category).permit(:name, :post_ids)
  end
end
```