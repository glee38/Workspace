
#Ruby
##About Ruby
###WORDS IN A PROGRAM
Every word and character in a program has to be valid code for the ruby language. Basically, every word can be one of three possible things:

+ A Ruby keyword, something that's part of the ruby language.
+ Literal data, things like "Strings" and Numbers 1,2.
+ Barewords you define and create, things like variables and methods.

**Anything that isn't one of those is invalid and the Ruby interpreter will throw an error.**

##WHAT IS IRB?

IRB stands for "interactive ruby", it's a ruby shell or REPL. REPL stands for read–eval–print loop. It is a simple, interactive computer programming environment that takes user inputs (such as, in our case, snippets of Ruby code), evaluates them, and returns the result to the user. IRB is run by your computer's terminal. You can think of it as your Ruby playground or execution environment. You can open it up, insert code and execute it to see that code's return value.

**How to run IRB:**

+ type **"irb"** into Terminal and press return
+ to leave irb, type the **"exit"** command

##Reading Error Messages
Error messages have 3 parts:

```lib/a_name_error.rb:3:in `<main>': undefined local variable or method `hello_world' for main:Object (NameError)```

1) The location of the error, the "where".

```lib/a_name_error.rb:3:in `<main>':```

+ `lib/a_name_error.rb` is the file the error occurred in.

+ 3 is the line of code the error.

+ `<main>` is the scope of the error.

2) The description, the "why".

```undefined local variable or method `hello_world' for main:Object```

+ The interpreter does the best job it can to tell you what it thinks went wrong.

3) The type of error, the "who".

`(NameError)`

This is a Ruby Error Type

###NAME ERRORS
NameErrors are caused when a given name is invalid or undefined. Whenever the Ruby interpreter encounters a word it doesn't recognize, it assumes that word is the name of a variable or a method. If that word was never defined as either a variable or a method, it will result in a name error.


###SYNTAX ERRORS
Syntax errors are pretty self-explanatory: they're the result of incorrect syntax. Thankfully, they're usually followed by a guess about the location of the error.

###TYPE ERRORS
When you try and do a mathematical operation on two objects of a different type, you will receive a TypeError. For example if you try and add a string to an integer, Ruby will complain.

###DIVISION ERRORS
DivisionErrors are caused when a given number is divided by 0.

##CLI Applications in Ruby

###CLI FILE STRUCTURE

As our applications increase in complexity we'll have to keep our project files well organized. There's a pretty standard convention for where to put code in a project based on what the code does.

We're going to learn a simplified pattern for organizing code in a Ruby application. We'll build on this structure.

###A SIMPLE RUBY CLI APPLICATION
From the root directory of a Ruby application, you should see a folder structure similar to the following:

```
├── bin
│   └── tictactoe
├── config
│   └── environment.rb
├── lib
│   └── tic_tac_toe.rb
└── spec
    ├── tic_tac_toe_spec.rb
    └── spec_helper.rb
├── Gemfile    
├── ttt.rb   
```
 
You might not have all those folders or those exact files, but you'll have a similar structure.

You'll see top-level directories (the top most folders within your project) such as: `bin`, `lib`, `config`, `spec` and sometimes `app`.

You also might see some top-level files (files located directly within your project) such as: `.learn`, `.rspec`, `Gemfile`, or` Rakefile`. On some labs you might see an actual program file on the top level, like `ttt.rb`.

We try to always tell you where the files you need to read or edit are located in a particular lab. This is just in general.

`cd` into the directory of a lab you recently solved in terminal. **Within that directory type `ls -lah` to list all the files in the current directory, including hidden files, in a human order**. You should see something similar.

Let's talk about what kind of code goes where.

###BIN/

Within the `bin/` directory we generally put code that relates to running our actual program. Our executable files that we put in bin are described below, running CLI applications.

###CONFIG/

A complex program might require 100s of individual files containing source code, method definitions, classes, and more that together constitute all the code required to run the application. We call this code the application's environment. We generally put all the code required to initialize the environment within `config/`. We might see that in an `config/environment.rb` file or even an entire `config/environments` directory.

What does it mean to "initialize a program's environment"? Establishing the environment for your program can involve a number of things, but on the most basic level, the config file or directory is responsible for things like file requirements (i.e. making sure your different files have access to one another), establishing connections to your database (if you have one) and ensuring that your test suite has access to the files that contain the code it is testing.

###LIB/ (APP/)

The `lib/` or Library directory in most Ruby programs and the `app/` directory in Rails projects or complex Ruby programs, is where the majority of our code lives. Within this directory are all the files that define what our program can do. All of the methods and classes our program needs are defined within the files in this directory. One file might define a group of methods that can search for a song by an artist, another file might define a group of methods that can search for a song by a genre. Together these methods might interact to create a Music Search application. **We spend the majority of our time building code in this directory.**

###SPEC/ (TEST/)

Great developers write tests for their code. Whether through the practice of Test-Driven Development or not, it's important to be able to write tests that make sure your code behaves as expected. It's also crucial to be able to read tests and understand the requirements they define for your code. All of our tests go into the `test/` or `spec/` directory.

###.RSPEC, .LEARN, GEMFILE, GEMFILE.LOCK, RAKEFILE

There are a collection of files in most Ruby applications that provide tooling and support for your application. A common such file is `Gemfile`, used by Bundler to manage gem dependencies. Another is a `Rakefile` for defining application tasks. Don't worry too much about these files for now.

**Advanced**: A gem is a library of code that you can include in your Ruby program to lend it the capabilities of that library.

###RUNNING CLI APPLICATIONS

In order to run our program from the command line and allow our user to interact with our program as described above, we need to set up a few things.

First, your program needs a `bin` directory. "Bin" is short for "binary" and is just another way to refer to executable files. Accordingly, your executable files belong in this directory.

**Executable files are any files that contain instructions in a form that a computer's operating system or application can understand and follow**. 

Any executable files we place in our bin directory need to begin with the following line:

`#!/usr/bin/env ruby`

This is often referred to as a "shebang line" and it tells the shell which interpreter to use to execute the remainder of the file.

Using the above setup, you can run your program by typing `ruby bin/< your file name >` into the command line.

Alternatively, you can execute your program by simply typing `./bin/< your file name >` into the command line, since the shebang line at the top of your executable file is already telling the shell to use Ruby to interpret the rest of the file.

Generally our executable file is responsible for running our program. That might include loading required libraries and starting off an execution flow, like telling Ruby to start a game of Tic Tac Toe.

###FILE PERMISSIONS AND CHMOD

For security purposes, a shell environment, including BASH, running within your terminal, requires that executable files are given explicit permission to execute.

When we execute code through the ruby interpreter with the `ruby` command, your shell or terminal has already given the `ruby` command permission to execute code.

But in order for your shell to execute a file via a command like `./bin/<file name>`, you have to grant it execute permissions. We do this using the `chmod` command. You can grant a file execute permissions with:

```
$ chmod +x <file_name>
```

So to grant a file `bin/tictactoe` permissions to execute, you would run: `chmod +x bin/tictactoe`. Depending on your shell environment and user, you might need to run `chmod` with `sudo` (`sudo chmod +x bin/tictactoe`).

All the files provided by Learn already have the correct permissions and this should never cause you a problem. But in the event you need to ever create your own executable, we thought we'd tell you.

###THE CLI INTERFACE

CLI Applications generally follow a similar interface or user experience pattern. Imagine a CLI version of Tic Tac Toe. From a player's perspective, they would start the game by executing the bin for the game.

```
$ bin/tictactoe
```

The program will execute and generally greet the user with some text output:

```
$ bin/tictactoe

Hi! Welcome to Command Line Tic Tac Toe! Would you like to
 play? (Y/n)
```

The CLI will prompt the user for input and will hang until the user types something and presses enter. The CLI generally gives instructions for the expected input at a given prompt. In the example above, the greeting ends by asking the user if they would like to play.

###USER INPUT
The `(Y/n)` at the end is a common convention for telling the user that the following prompt is looking for a "Yes" or "No" input as an answer. It is also saying it expects that input as a single character, either `y` or `n`. The capital `Y` is suggesting the default input if the user types nothing and simply presses enter. Generally CLIs will accept "Yes"/"No" in many forms (`yes`, `no`, `N`, `n`) and still use the `y/n` convention.

```
$ bin/tictactoe

Hi! Welcome to Command Line Tic Tac Toe! Would you like to
 play? (Y/n)
y ↵
Great! Starting a new game...

   |   |   
-----------
   |   |   
-----------
   |   |   

Please select a square by entering 1-9, 1 for the top left 
and 9 for the bottom right:


```

*↵ is a Carriage Return symbol and simply means the "Enter" key was pressed. It is not literal. In the line above it is used to mean that the user entered in the y character at an input prompt and then pressed enter.*

For more complex interactions, the CLI must inform the user about the custom input prompt, just like in the example above: 

```
Please select a square by entering 1-9, 1 for the top left 
and 9 for the bottom right:
``` 

We just tell the player to enter a number, 1 through 9, to represent the square.

```
$ bin/tictactoe

Hi! Welcome to Command Line Tic Tac Toe! Would you like to play? (Y/n)
y ↵
Great! Starting a new game...

   |   |   
-----------
   |   |   
-----------
   |   |   

Please select a square by entering 1-9, 1 for the top left and 9 for the bottom right:
5↵

 O |   |   
-----------
   | X |   
-----------
   |   |   

Please select a square by entering 1-9, 1 for the top left and 9 for the bottom right:
7↵

 O |   |   
-----------
   | X |   
-----------
 X |   |   
```

*Etc...*

That is a simple CLI interface pattern. Whenever you ask the user for input, you will need to:

+ Prompt the user for input: `Would you like to play? (Y/n)`
+ Define the input interface: 

```
Please select a square by entering 1-9, 1 for the top left
 and 9 for the bottom right:
```

+ Accept user input by yielding to a prompt and waiting patiently for the user to press enter. *If the user never enters anything, the program will wait at this state forever until the process is otherwise terminated.*

+ Take the user input and execute the appropriate sub-routine or procedure that represents that feature.

Another pattern is to provide your CLI with a main **program loop** so that it can provide a bigger set of menus and features.

###Program Loop

CLI programs have to continue running and accepting input from the user until they are explicitly exited through sending a termination signal to the program by pressing `CTRL+C` (on OS X, on Windows and other environments it might be `ALT+C` or `COMMAND+C`), or by telling the program to quit or exit through some sort of input.

Imagine a Command Line Jukebox application to browse and play music through the Command Line (like Spotify or iTunes). It might look like this when run:

```
$ bin/jukebox

Hi! Welcome to Command Line Music.

What would you like to do?
I accept: list, play, help, and quit.
help↵

Main Menu Commands:
  help - Brings up this dialog.
  list - Will list all the songs in my collection.
  play - Will prompt for a song to play and play that song.
  quit - Will exit this program

What would you like to do?
I accept: list, play, help, and quit.
list↵

My songs are:
1. Shake It Off, by Taylor Swift
2. In An Aeroplane Over the Sea, by Neautral Milk Hotel
3. Reality Check, by Binary Star
4. Hey boy, hey girl, by the Chemical Brothers

What would you like to do?
I accept: list, play, help, and quit.
play↵

Please enter the song number you would like to play:
3↵

Reality Check, by Binary Star is currently open in your browser.

What would you like to do?
I accept: list, play, help, and quit.
```

Within the transcript of this program you can see the structure of the main application loop.

After the initial greeting, the application begins its main loop, which consists of:

+ Prompting the user for input: What would you like to do?

+ Defining the input interface: `I accept: list, play, help, and quit.`
+ Accepting user input by yielding to a prompt and waiting patiently for the user to press enter. *If the user never enters anything, the program will wait at this state forever until the process is otherwise terminated.*
+ Taking the user input and executing the appropriate sub-routine or procedure that represents that feature. If a user enters 'help', the program should print the help instructions.
+ Once that feature terminates, the program is back at the start of the main loop.

Any CLI application you build that neccesitates a non-binary interface ("Do you want to play Tic Tac Toe?" vs "What game would you like to play?") will have a main loop interface as described above.

##PROJECT STRUCTURE

Check out the file structure below.

```
bin
   |–– greeting
lib
   |–– hello_ruby_programmer.rb
...
```

Let's take a moment to review:

###THE BIN DIRECTORY
The `bin` directory holds our executable file. **This file is responsible for running the program. It contains code that actually enacts the command line interaction––i.e. greeting the user, asking the user for input, storing that input and then acting on it.**

Open up `bin/greeting`. Notice that we are requiring the `lib/hello_ruby_programmer.rb` file.

###THE LIB DIRECTORY
The `lib` directory is where we place the code that our program relies on to run. It is the meat of our CLI application. Our executable file requires the files in the `lib` directory and uses the code (for example, calling on any methods we might define) to to enact the CLI.

Open up `lib/hello_ruby_programmer.rb` file. Notice that it defines a `#greeting` method that is called in the `bin/greeting` file. This is the pattern you'll become familiar with for CLI applications––defining methods in a `lib` directory and calling those methods in `bin` executable files to actually run the program.

Now, let's take a closer look at our code.

###THE CLI PATTERN

In `bin/greeting` you should see the following code:

```
puts "Hi! Welcome to the wonderful world of Ruby programming."
puts "Please enter your name so that we can greet you more
 personally:"
name = gets.strip
greeting(name)
```

Here, we have all of the CLI flow steps outlined above. Let's break it down:

1 . Greet the user:

`puts "Hi! Welcome to the wonderful world of Ruby programming."`

2 . Ask the user for input:

`puts "Please enter your name so that we can greet you more personally:"`

3 . Capture that input using `#gets`

`name = gets.strip`

4 . Use that input to do something else:

`greeting(name)`

In this case, we are passing the user's input into the `#greeting` method as an argument. The greeting method then uses string interpolation to `#puts` out a personalized message.

###THE GETS METHOD

We've talked a lot about capturing and storing a user's input to the terminal and using it in our Ruby program. Now we'll take a closer look at exactly how that happens.

Let's take another look at our code from `bin/greeting`

```
puts "Hi! Welcome to the wonderful world of Ruby programming."
puts "Please enter your name so that we can greet you more personally:"
name = gets.strip
greeting(name)
```

On the third line, the `gets` method is being called. Calling the `gets` method captures the last thing the user typed into the terminal. Whenever your program makes a call to `gets`, it will freeze and wait for user input.

###WAITING FOR THE USER INPUT
If the user never types anything in, your program will wait forever until it is otherwise exited. If you find your tests and your program stalling for long periods of time (anything over 5-10 seconds generally), you might be trapped in a `gets`.

From executing a program, a gets will look like:

![gets in program] (https://dl.dropboxusercontent.com/s/ezddrtyotw5ahow/2015-09-10%20at%2012.12%20PM.png)

From a test run, a stalled gets will look like:

![gets in test] (https://dl.dropboxusercontent.com/s/tijh1wyuvdfz11a/2015-09-10%20at%2012.13%20PM.png)

###RETURN VALUE FOR GETS
The return value of `gets` is the text typed into the terminal. So, setting a variable, `name`, equal to invoking the `gets` method sets that variable equal to the return value of `gets`––the last thing typed into the terminal. Then, the following line uses that `name` variable in string interpolation.

Once we store the return value of `gets` in a variable, we can treat that variable as we would any variable pointing to a string––interpolate with it, convert it to an integer, add it to an array, you name it.

###ADVANCED: HOW GETS GETS INPUT FROM THE TERMINAL
We already know, in general terms, how the puts method outputs text to the terminal, but here's a reminder from an earlier lesson, "Puts, Print and Return":

How do the puts and print methods actually output text to your console? They use the `$stdout` global variable provided to us by Ruby.

The gets method wraps the `$stdin` variable, reading text from the standard input and allowing you to store that text in a variable, so that you can operate on it later.

###SANITIZING USER INPUT: THE STRIP AND CHOMP METHODS
One thing to know about the `#gets` method is that it captures a new line character at the end of whatever input it is storing. We don't want extra whitespace or new lines to be appended to the user input we are trying to store. So, we can chain a call to the `#stripmethod` to remove any new lines or trailing whitespace.

The `#chomp` method works similarly, and you are likely to see `#gets.chomp` used in some examples online. The `#chomp` method removes any new lines at the end of a string while the `#strip` method removes both trailing whitespace and new lines.

##Ruby Data Types
Ruby has **six** data types, which are also known as *classes*: booleans, symbols, numbers, strings, arrays, and hashes.

##STRINGS
###CREATING STRINGS
There are two ways to create a string. In fact, we've already created a string just by typing "hello".

Try it out by opening up IRB, and typing "hello".class

You should see a return value of => String. You can actually call .class on any object to find out what type of data, i.e. what class, it is.

**The Literal Constructor**: This is the method through which we created our "hello" string.

**The Class Constructor**: You can also create a string with String.new. This will create an empty string.

String.new("hello") on the other hand, will create this string: "hello". For the most part, you will create strings using the first method discussed here––simply by enclosing whatever text you want in quotes.

##BOOLEANS

There are only two values of the Boolean data type: **true and false**. In Ruby, however, there is no such thing as a Boolean class. Instead, every appearance, or instance, of true and false in your program are instances of TrueClass and FalseClass respectively.

###NUMBERS

You probably already know from the real world (as opposed to the Ruby world) that integers are numbers. **In Ruby, there are two types of numbers: Fixnums and Floats.**

+ **Fixnums** are *whole numbers*, like 7.

+ **Floats** are *decimal numbers*, like 7.3.

###CREATING INTEGERS

Once again, there is no special magic to creating integers. Simply declare them by typing 9000123 or 2.
OPERATING ON FIXNUMS AND FLOATS
There are a number of methods available to you for operating on or manipulating integers. You can read more about Fixnums here and more about Floats here For now, we'll just check out a few examples:

~~~
7.5.floor
  => this method will round the float down to the nearest fixnum. Here it will return 7

7.5.ceil
  => 8
10.next
  => 11
~~~

##SYMBOLS

A symbol is a representation of a piece of data. 

Symbols look like this:

~~~
:my_symbol
~~~ 

If I make a symbol, :my_symbol, and then use that symbol later on in my code, my program will refer to the same area of memory in both cases. This is different from, for example, strings, which take up new areas of memory every time they are used.

###CREATING SYMBOLS
You write symbols by placing a : in front of the symbol name.

~~~
:this_is_a_symbol
~~~

##ARRAYS

Arrays are collections of Ruby objects. You can store any type of data in an array.

###WHAT IS AN ARRAY?

So far, we've used variables to store information. For example, I could create a variable called `my_name` and set it equal to my name: `my_name ="Severus Snape"`. However, variables only allow us to store one piece of information at a time.

What if my boss, Headmaster Dumbledore, asks me to deliver the names of all of my students? I could create a bunch of variables like this:

~~~
student_1 = "Harry Potter"
student_2 = "Ron Weasley"
student_3 = "Hermione Granger"
student_4 = "Draco Malfoy"

# etc...
~~~
I could write a program that passes around these variables one at a time. This seems messy though. I could easily forget about a student, for example. Or need to create a new student and then have to hunt through my program for every place I ever passed around all of these individual variables.

If this was real life, Professor Snape would probably just write down all the students in list form and hand that list to Dumbledore. Well, in Ruby, we can do the same thing using an array.

**An array is like a list but in code form.** It is a way for your program to store pieces of data as a collection. *Arrays can contain any data types in any combination––strings, integers, other arrays, hashes, etc.*

Arrays are declared by listing variable names or literals separated by commas (`,`) and wrapped in square brackets `[ ]`. To save our four students from above into an array, we write that in our code like this:

~~~
students = ["Harry Potter", "Ron Weasley", "Hermione 
Granger", "Draco Malfoy"]
~~~


###CREATING ARRAYS
There are a number of ways to create an array. Just like with creating strings, you can use the *literal constructor* or the *class constructor*.

+ **The Literal Constructor**:`[1, 3, 400, 7]` is an array of integers. Any set of comma separated data enclosed in brackets is an array. So, by simply writing something like the above, you can create an array.

	+ `my_array = []`

+ **The Class Constructor**: You can also create an array with the `Array.new` syntax. Just typing `Array.new` will create an empty array (`=> []`).
	+ `my_array = Array.new #=> []`

**Advanced**: A class is like a template, or blueprint, for creating objects in Ruby. An **"object"** is simply a bundle of information and behaviors. 

+ For example, a string is an object, because it contains information (i.e. the text inside the " ") and because it has behaviors––it can do things/have things done to it. 

For example:

	+ `"hi".reverse #=> "ih"`

	
There is an Array class that serves as the blueprint for every array that you will make. This means that all arrays are capable of certain shared behaviors and are responsive to certain methods.

To create a new array object from the Array class, you can call `.new` on `Array` – the name of the class. This creates a brand new, empty array. Don't worry about understanding objects and classes, or the `.new` method, just yet. They are all part of something called Object Oriented Programming, which is a big topic. We'll be building up to it through this and the next few units.

To make an array that isn't empty, you can separate each item, known as an element, by a `,` ("comma") and wrap all the elements inside `[ ]` ("square brackets").

```
puppies = ["bulldog", "terrier", "poodle"]
# => ["bulldog", "terrier", "poodle"]

random_numbers = [ 2, 5, 6, 8, 30050]
# => [ 2, 5, 6, 8, 30050]

mixed = ["this", "array", 7, 20, "has", 45, "integers",
 "&", "strings", 309]
# => ["this", "array", 7, 20, "has", 45, "integers",
 "&", "strings", 309]
```
It is possible to create an array that contains disparate data types, but that is generally discouraged. It's best to keep your arrays populated with only one kind of element.


###OPERATING ON ARRAYS
There are many ways to operate on arrays and on each individual item, or element, within an array. Later on in the course, we'll learn about iteration––the process of operating on each successive item in an array. For now, we'll preview a few array methods:

~~~
[5, 100, 234, 7, 2].sort

  => [2, 5, 7, 100, 234]

[1, 2, 3].reverse
  => [3, 2, 1]
~~~

###RETRIEVING ITEMS FROM ARRAY

When you write out a list on a notepad, you typically write each item on its own line. Whether or not the list is explicitly numbered, the list has a numerical order to it based on the sequence of the lines that the items are listed upon.

Just like the items in our notepad lists, elements in an array are associated with a number that represents their order. In programming, this number is called an **index**. While humans typically start their lists at "1.", arrays begin their indexes at `0` (zero). So, the first item in array will always be "at index `0`". If we have an array of famous (fictional) cats:

`famous_cats = ["Cheshire Cat", "Puss in Boots", "Garfield"]`

The `"Cheshire Cat"` is at index `0` in the array, `"Puss in Boots"` is at index `1`, and `"Garfield"` is at index `2`. **Indexes will always be one less than the count.**

To access one of these items in the `famous_cats` array, we can type the name of the array immediately followed by the relevant index number wrapped in square brackets (`[ ]`).

~~~
famous_cats =  ["Cheshire Cat", "Puss in Boots",
 "Garfield"]

famous_cats[1]  #=> "Puss in Boots"

famous_cats[0] #=> "Cheshire Cat"

famous_cats[2] #=> "Garfield"

famous_cats[20] #=> nil
~~~

###ASSIGNING NEW VALUES TO AN ARRAY

Now that we know how to create an array with literal constructors `[ ]` and read values out of an array via the index of the element like `["Red", "Yellow", "Green"][0]` for `"Red"`, we should learn how to re-assign a value to an index in an array.

`speed_dial = ["Ada", "Kay", "Matz", "DHH", "Borg"]`

We have five of our favorite friends in an array referenced by the local variable `speed_dial`. If we wanted to get the name of the person in the third position of our speed dial, we would call `speed_dial[2]` and it would return `"Matz"`.

But what about replacing someone in our speed dial? How could we replace `"Kay"` in index `1` of `speed_dial` with our new second favorite friend, `"Chipps"`?

To re-assign a value to an index in an array we use the `[ ]=` syntax. We must supply an index we want to re-assign and then a value for that index. For example:

```
speed_dial = ["Ada", "Kay", "Matz", "DHH", "Borg"]
speed_dial[1] #=> "Kay"

speed_dial[1] = "Chipps"
speed_dial[1] #=> "Chipps"
```

Re-assigning a value to an index of an array looks a lot like variable definition and that is by design. Just indicate which index you want to write to with `[ ]`, and then assign it a new value with `=`. The old value is totally forgotten and replaced by the new value.

###MANIPULATING ARRAYS

If an array is a storage container for a list of data, then we can add and remove individual items from it. There are several ways to accomplish either.

###ADDING ITEMS TO AN ARRAY

**SHOVEL METHOD**

The shovel method employs the "shovel" operator `<<` and allows you to **add ("shovel") items onto the end** of an array:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats << "nala cat"

famous_cats #=> ["lil' bub", "grumpy cat", "Maru", 
"nala cat"]
```

The shovel method `<<` is the preferred syntax for adding elements to an array, however you might see other methods used in examples online:

**THE .PUSH METHOD**

Calling `.push` on an array with an argument of the element you wish to add to that array, will also add that element to the end of the array. It has the same effect as the shovel method explained above:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats.push("nala cat")

famous_cats #=> ["lil' bub", "grumpy cat", "Maru", 
"nala cat"]
```

**THE .UNSHIFT METHOD**

To **add an element to the front** of an array, you can call the `.unshift` method on it with an argument of the element you wish to add:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats.unshift("nala cat")

famous_cats.inspect #=> ["nala cat", "lil' bub", "grumpy 
cat", "Maru"]
```

###REMOVING ITEMS FROM AN ARRAY

**THE .POP METHOD**

Calling `.pop` on an array will **remove the last item from the end of the array**. The `.pop` method will also supply the removed element as its return:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]
maru_cat = famous_cats.pop

famous_cats #=> ["lil' bub", "grumpy cat"]
maru_cat #=> Maru
```

**THE .SHIFT METHOD**

Calling `.shift` on an array will **remove the first item from the front of the array**. The `.shift` method will also supply the removed element as a return:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]
lil_bub = famous_cats.shift

famous_cats #=> ["grumpy cat", "Maru"]
lil_bub #=> lil' bub
```

###OPERATING ON ARRAYS

There are a number of other methods available for manipulating arrays. You can learn more about them here, but we'll look at just a few examples together.

**THE .REVERSE METHOD**

This method **reverses an array**.

```
famous_wizards = ["Dumbledore", "Gandalf", "Merlin"]

famous_wizards.reverse #=> ["Merlin", "Gandalf", 
"Dumbledore"]
```

**THE .INCLUDE? METHOD**

This method will **return a boolean of whether or not the array contains (or includes) the element submitted to it inside the parentheses**:

```
famous_cats = ["lil' bub", "grumpy cat", "Maru"]

famous_cats.include?("Garfield") #=> false

famous_cats.include?("Maru") #=> true
```

##METHODS

###WHY USE METHODS
**Methods define a new thing that your program can do.** Variables are a mechanism to teach your Ruby program about data; methods teach your Ruby program about a new routine or behavior it can use. **Variables are like nouns, methods are like verbs.**

For example, imagine needing to say "Hello World!" ten times. The method would look like this:

```
def say_hello_world_ten_times
  phrase = "Hello World!"
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
  puts phrase
end
```
Now, when we use the bareword `say_hello_world_ten_times` in our program, it will invoke the method, running the code within the method. 

###DEFINING A METHOD
You can define a method in Ruby with the `def` keyword. A method's name can begin with any lowercase letter. Here's a quick example:

```
def greeting # Method Signature
  puts "Hello World" # Method Body
end # Method Closing
```

+ That first line, `def greeting`, is called the **method signature**, it defines the basic properties of the method including the name of the method, `greeting`.

+ Once you open a method definition with the `def` keyword, all subsequent lines in your program are considered the **method's body**, the actual procedure or code that your method will run every time it's called.

+ You must terminate every opening `def` of a method with a corresponding `end` in order to close the method body.

+ It's also a great practice to indent methods correctly. **The body of a method should be indented two (2) spaces**, placing it visually within the method. When you `end` the method, go back to the same indentation of the `def`, aligning the opening and closing of the method visually.

**NOTE**: Programmers love conventions, or agreed upon rules that help them talk to each other about code. A common convention for Ruby methods is to preface them with a `#`, and in subsequent lessons, you might see methods written with a `#` in front of the method name. This is so that other rubyists can instantly recognize it as a method, as opposed to a variable or a bareword or a class. For example, if a method is named '`greeting`', rubyists will often refer to it as '`#greeting`'. But remember that when you write it in your code, it should be `greeting` and not `#greeting`.

**ANOTHER WAY TO DEFINE METHODS**

Now that we've specified a name for our new method, we may need to declare some parameters. These are simply a list of local variable names in parentheses. Some sample method declarations are

```
def myNewMethod(arg1, arg2, arg3)     # 3 arguments
  # Code for the method would go here
end

def myOtherNewMethod                  # No arguments
  # Code for the method would go here
end
```

Ruby lets you specify default values for a method's arguments---values that will be used if the caller doesn't pass them explicitly. This is done using the assignment operator.

```
def coolDude(arg1="Miles", arg2="Coltrane", arg3="Roach")
  "#{arg1}, #{arg2}, #{arg3}."
end
coolDude	»	"Miles, Coltrane, Roach."
coolDude("Bart")	»	"Bart, Coltrane, Roach."
coolDude("Bart", "Elwood")	»	"Bart, Elwood, Roach."
coolDude("Bart", "Elwood", "Linus")	»	"Bart, Elwood, Linus."
```

The body of a method contains normal Ruby expressions, except that you may not define an instance method, class, or module within a method. The return value of a method is the value of the last expression executed, or the result of an explicit return expression.

##METHODS AND ARGUMENTS

###UNDERSTANDING ARGUMENTS

Imagine needing to build a method that greets a person. We could code something like this:

```
def greeting
    puts "Hi, Ruby programmer!"
end
```

This method, when called, will print out to the terminal, the string `"Hi, Ruby programmer!"`. 

You should see:

```
Hi, Ruby programmer!
 => nil 
```
 
As amazing as this method is, it's still pretty literal. It hard-codes, or directly specifies, name of the person we are greeting as `"Ruby programmer"`. If we wanted to build a method that can greet anyone, even Python programmers, we'd have to re-implement the majority of the original logic from greeting:

```
def greeting_python
  puts "Hello, Python programmer!"
end
```

Notice the only things that changed are the method name and the language name `"Python"` in the body of the method. It's as though that information should be specifiable or configurable when you call the method, otherwise we'd have to build every permutation of the method. In other words, we'd have to re-write the method for every single person we want to greet. We want our method to be more dynamic, more abstract, more re-usable. It should maintain the elements that will always be the same, no matter who we greet, and allow us to change, or swap out, the name of the person we are greeting. **This is dynamic, as opposed to "hard-coded"**.

**Good news, that's exactly what method arguments (also called parameters) are for**:

```
def greeting(name)
  puts "Hello, #{name}!"
end
```

Above, we define our method to take in an argument by following the method name with parentheses enclosing a variable name: `greeting(name)`.

Then, we use **string interpolation** inside the method body to `puts` out a greeting using whatever `name` was passed into the argument when the method is called. String interpolation allows users to use a Ruby variable to render a value inside of a string. In other words, if we have a variable, `name`, that points to a value of `"Sophie"`, string interpolation will let us use that `name` variable inside a string to render, or `puts` out, a string that contains the word `"Sophie"`.

To interpolate a variable into a string, wrap that variable name inside curly braces, preceded by a pound sign: `#{variable_name}`.

Let's call our method and see it in action:

```
greeting("Sophie")
# > Hello, Sophie!
```

###DEFINING METHOD ARGUMENTS

To add arguments to a method, you specify them in the method signature––the line that starts with `def`. Simply add parentheses after the name of the method and create a placeholder name for your argument.

For example, if I want to write a method called `greeting` that accepts an argument of a person's name, I would do it like this:

```
    #method name      #argument
def greeting_a_person(name)
  "Hello #{name}"
end
```

Arguments create new local variables that can be used within the method. When you name an argument, you are defining what bare word you want to use to access that data, just like when you create a variable. **Arguments follow the same rules as local variables: they can be any word that starts with a lowercase letter and they should be as descriptive of the data as possible.**

In our `#greeting` method example, we are saying: When you call the `#greeting` method with an argument of `"Sophie"`, set a variable `name` equal to the value of `"Sophie"`.

###DEFINING METHODS WITH MULTIPLE ARGUMENTS

You can define a method to accept as many arguments as you want. Let's try creating a method that accepts two arguments: a person's name and their programming language of choice.

```
  # method name      first_argument, second_argument
def greeting_programmer(name, language)
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end


greeting_programmer("Sophie", "Ruby")
# > Hello, Sophie. We heard you are a great Ruby programmer. 

greeting_programmer("Steve", "Elixir")
# > Hello, Steven. We heard you are a great Elixir programmer.
```

**To accept multiple arguments, simply separate the bare words in the argument list with commas.**

###REQUIRED ARGUMENTS

Once you define arguments for a method, they become required when you invoke or call the method. If you define a method that accepts a singular argument, when you call that method, you must supply a value for that argument, otherwise, you get an `ArgumentError`. Here's an example:

```
def greeting(name)
  puts "Hello, #{name}!"
end

greeting # I explicitly call the method without a value for 
the argument `name`
# > ArgumentError: wrong number of arguments (0 for 1)
```

In Ruby, all arguments are required when you invoke the method. You can't define a method to accept an argument and call the method without that argument. Additionally, a method defined to accept one argument will raise an error if called with more than one argument.

```
def greeting(name)
  puts "Hello, #{name}!"
end

hello("Sophie", "Ruby") # The method accepts 1 argument and 
I supplied 2.
# > ArgumentError: wrong number of arguments (2 for 1)
```

By default, all arguments defined in a method are required in order to correctly invoke (or "call", or "execute") that method.

###USING ARGUMENTS IN METHODS

Now that we know how to define a method with arguments, let's take a closer look at using those arguments, that data, within the method. Once again, our greeting method:

```
def greeting(name)
  puts "Hello, #{name}"
end
```

When we define a method with arguments we are defining a bareword that we can use to reference the actual value supplied to the method upon invocation. We built a method that will greet a specified person. In order to write code in our method to actually greet any given person, we need a placeholder––a way to refer to a generic person's name. This is an argument.

When we build that method we might ask ourselves, "who is this method designed to greet?". The answer is "anyone, it doesn't matter." That's what makes the method abstract, the detail of who it greets is hidden until the method is actually invoked: greeting("Sophie"). Only then do we know that the method greets Sophie. The value of name is only supplied upon invocation.

The bareword, in this case name, that we use as the argument's name in the method signature becomes a local variable within the method. Through that variable we can reference the value of the argument supplied at invocation.

With the code above, when we say: greeting("Sophie"), the value of the argument name is "Sophie". During the particular runtime invoked by greeting("Sophie"), any reference to name will have the value of "Sophie", allowing the method to behave as intended.

Similarly, when we say: greeting("Ann"), the value of the argument name is "Ann".

Method arguments simply create local variables for you to refer to the value used when the method is actually invoked.

###A NOTE ON METHODS ENDING IN A ?

Conventionally, we name methods that return either `true` or `false` with a question, ending in a literal question mark. One of the most appealing features of Ruby, especially from the point of view of beginner programmers, is it's readability. Ruby lends itself especially well to elegant and sensical statements. So, if our method is meant to answer the question: "is this position taken?", we will phrase our method definition just like that.

##WHY OPTIONAL ARGUMENTS?

We should constantly strive for our code to be dynamic and flexible. As programmers, we are lazy (which is a virtue). Consequently, we want the code we write to be re-usable.

If we define a method, `#greeting`, like this:

```
def greeting
  puts "Hello, Ruby programmer!"
end
```

We have to re-define or re-write that method every time we'd like to use it to greet someone else who might not be a Ruby programmer. Since that's way too much work for us, we'll define our method to take in an argument of someone's name:

```
def greeting(name)
  puts "Hello, #{name}"
end
```

Now our method is flexible and dynamic, it can be used again and again to greet different people.

But what if we don't know the name of the person we are trying to greet? We can make this method even more flexible by making the name argument optional. We do this by using optional, or default, arguments.

###DEFAULT ARGUMENTS

In order to define a method that optionally takes in an argument, we define our method to take in an argument with a default value. By defining our method with default arguments, we make it possible to call the method with optional arguments, i.e. with or without arguments.

```

#             assigning a default value
def greeting(name = "Ruby programmer")
  puts "Hello, #{name}"
end
```

In our argument list, `(name = "Ruby programmer")`, we simply assign the argument name a default value of `"Ruby programmer"`. By doing so, we are really saying:

If the method is invoked without any arguments, i.e. like this: `greeting`, Ruby will assume the value of the `name` variable inside the method to be `"Ruby programmer"`.

However, if the method is invoked with an argument, `greeting("Sophie")`, Ruby will assign the variable `name` to the string `"Sophie"` inside the method.

```
greeting
# > Hello, Ruby programmer!

greeting("Sophie")
# > "Hello, Sophie!"
```

With default arguments, our once simple machine becomes profoundly useful and abstract.

###ADDING DEFAULT ARGUMENTS

Default arguments are easy to add, you simply assign them a default value with = ("equals") in the argument list. There's no limit to the amount of arguments that you can make default.

```
def greeting(name="Ruby programmer", language="Ruby")
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end
```

Let's take a look at the different ways we can call this method:

```
greeting
# > Hello, Ruby programmer. We heard you are a great Ruby programmer. 

greeting("Sophie")
# > Hello, Sophie. We heard you are a great Ruby programmer. 

greeting("Steven", "Elixir")
# > Hello Steven. We heard you are a great Elixir programmer.
```

###USING DEFAULT ARGUMENT AND REQUIRED ARGUMENTS

It is possible to define a method that takes in both required and default arguments. To do so, however, we must place the default argument at the end of the argument list in the method definition.

Take a look:

```
def greeting(name, language="Ruby")
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end
```

Let's call our `#greeting` method with and without an explicit `language` argument:

```
greeting("Sophie", "Ember.js")
# > Hello, Sophie. We heard you are a great Ember.js programmer. 

greeting("Dan")
# > Hello, Dan. We heard you are a great Ruby programmer.
```

It works! Why must we place the default argument at the end of the argument list?

Let's take a look at what would happen if we didn't:

```
def greeting(language="Ruby", name)
  puts "Hello, #{name}. We heard you are a great #{language} programmer."
end
```

Now, what happens when we try to call our method without an explicit `language` argument?

```
greeting("Sophie")
```

You might expect it to break. Or you might expect it think that the `language` variable is being set equal to `"Sophie"` in this method call.

Neither of those things will happen. The method will work as we intended because Ruby is smart and has a few tricks up its sleeve to help determine what method arguments are being used where in a method's body.

However, defining the default argument first is confusing. We can understand this from our very reasonable expectations that the above method invocation would break. For this reason, it is conventional to place any default arguments at the end of an argument list when defining a method that takes in both required and default arguments.

##VARIABLES

###HOW YOU INTERPOLATE VARIABLES INTO STRINGS

To interpolate, you wrap the variable like `#{this}`.

Let's try:

```
puts "There are #{num_of_attendees} people coming to
 Beyonce's birthday party."
```
This prints `There are 547 people coming to Beyonce's birthday party.`

###ANOTHER WAY TO INTERPOLATE VARIABLES INTO STRINGS

Some Rubyists write this another way, like this:

```
answer = "Flamboyance"
puts "A group of flamingos is called a " + answer + "."
```
##BOOLEANS AND FLOW CONTROL

Many programming languages, including Ruby, have native **boolean (true or false)** data types. In Ruby they're expressed directly as `true` and `false`.

These boolean values come in handy in programming when we want to implement control flow. **Control flow** is the idea that we can tell our program to execute certain lines of code based upon certain conditions.

+ **For example**, *if* I am tired, then I will take a nap. Otherwise, I will keep reading this insightful and informative readme. You could also invert the perspective like in this example:

	+ If it is *true* that I am tired, then I will take a nap. If it is *false* that I am tired, then I won't take a nap.

Flow control is predicated on these true-or-false boolean values. The adjectives "truthy" and "falsey" are a programming convention for describing the *state* of being true and the state of being false.

What this example amounts to is this: we want to be able to use non-boolean values (like strings or integers) in a boolean context; we want to be able to say, "*if* a certain statement *evaluates* to true (or is "truthy"), then execute these certain lines of code."

Consequently, Ruby must have a way of determining what counts as true at a given moment—or what is "truthy" versus what is "falsey".

###WHAT IS 'TRUTHY' AND 'FALSEY' IN RUBY?

Programming languages are software, too! That means the people who built Ruby had to decide what is truthy and what is falsey. Different languages make different decisions.

**In Ruby only `false` and `nil` are falsey. Everything else is truthy (yes, even `0` is truthy).**

Become familiar with the following chart:

Value |	Truthy?
------|---------------
0	| yes
" " |	yes
"hello" |	yes
nil	| no
6.7 |	yes
true |	yes
false |	no
[1,2]	| yes
{:hi=>"there"}	| yes

**Top-Tip**: Even an empty string, `" "`, is truthy! This might seem kind of strange, but it will make more sense once we learn more about object orientation. For now, keep in mind that even an empty string is an instance of the String class. 

###BONUS: DETERMINING TRUTHINESS
If you forget to memorize this handy chart, there is a trick you can use to determine if a value is truthy or falsey.
A **single bang operator**, `!`, will negate the boolean value it is placed in front of. For example:

```
!true  #=> false
```

and

```
!false #=> true
```

**The double bang operator**: A "double-bang operator" (`!!`) will return `true` or `false` based on whether a value is truthy or falsey to begin with.

For example:

```
!!"hello" #=> true

!!nil #=> false
```

##BOOLEANS
We've already learned a bit about the boolean (true-or-false) data type. In Ruby, a boolean refers to a value of either `true` or `false`, both of which are defined as their very own data types. Every appearance, or instance, of `true` in a Ruby program is an instance of `TrueClass`, while every appearance of `false` is an instance of `FalseClass`.

For now, we don't need to understand the concept of classes in depth. Just know that classes serve as templates for Ruby objects. Think of `TrueClass` and `FalseClass` like cookie cutters––there is a `TrueClass` cookie cutter and a `FalseClass` cookie cutter and every appearance of `true` or `false` is like a cookie made with its respective cookie cutter.

##BOOLEAN OPERATORS

###WHAT ARE BOOLEAN OPERATORS?
Boolean operators are really methods which means that they have return values. What do they return? `true` or `false` of course!

**In Ruby there are three main boolean operators**:

+ `!` ("single-bang") which represents **"NOT"**

+ `&&` ("double-ampersand") which represents **"AND"**

+ `||` ("double-pipe") which represents **"OR"**.

For an `&&` ("and") to evaluate to `true`, both values of either side of the symbol must evaluate to `true`. 

+ For example:

```
true && true #=> true

true && false #=> false
```

For an `||` ("or") to evaluate to `true`, only **one** value on either side of the symbol must evaluate to true. 

+ For example:

```
false || true #=> true
```

Finally, a `!` ("not") reverses the logical state of its operand: if a condition is `true`, then `!` will make it `false`; if it is `false`, then `!` will make it `true`. 

+ For example:

```
!true #=> false

!false #=> true
```

##COMPARISON OPERATORS

To check if two values are equal, we use the comparison operator represented with `==` ("double-equal-sign"). If two values are equal, then the statement will return `true`. If they are not equal, then it will return `false`. 

+ For example:

```
1 == 1 #=> true

1 == 7 #=> false
```

**Top-tip**: The *comparison* operator `==` is distinct from the *assignment* operator `=` that is used to set a variable equal to a value. Mistaking these for each other is a common cause of unexpected behavior.

###MORE COMPARISON OPERATORS

Ruby is good at comparing things. For instance, it knows that `14` is larger than `3`. Let's see that in action.

```
14 > 3 #=> true
```

Here, `14` is larger than `3`, so Ruby evaluates this to `true`. Comparisons in Ruby always evaluate to `true` or `false`.

**The commonly used comparison operators are:**

Operator |	Operation
---------|-------------
`==`	| If the values of the two operands are *equal*, then the evaluation is `true`.
`!=	`| If the values of the two operands are *not equal*, then the evaluation is `true`.
`>`	| If the value of the left operand is *greater than* the value of the right operand, then the evaluation is `true`.
`<`	| If the value of the left operand is *less than* the value of the right operand, then the evaluation is `true`.
`>=`	| If the value of the left operand is *greater than or equal to* the value of the right operand, then the evaluation is `true`.
`<=`	| If the left operand is *less than or equal to* the value of the right operand, then the evaluation is `true`.

+ Ruby can compare a lot more than just numbers. It can also compare strings:

```
"yellow" == "yellow" #=>true
```

+ And variables with known values:

```
my_mood = "happy"

my_mood == "happy" #=> true
```

+ It can also compare variables against other variables:

```
easter_eggs = 16
ducklings = 3

easter_eggs > ducklings #=> true

ducklings >= easter_eggs #=> false

ducklings == easter_eggs #=> false

# if you call class on a variable, you can see if it's a
 string, an integer, etc.

ducklings.class #=> Integer
easter_eggs.class #=> Integer
ducklings.class == easter_eggs.class #=> true
```

Comparison operators are essential to developing logical flow.

##WHAT IS FLOW CONTROL?

**A control flow construct is a language feature which disrupts the normal progression to the next statement and conditionally or unconditionally branches to another location in source code. –– Robert Klemme**

**In other words, control flow lets you tell your program what code to execute conditionally.** As humans, we actually enact flow control every day. For instance, if you are hungry, you will go and get a snack. Otherwise, you'll stay put and continue to read this awesome readme.

Control flow is an important part of Ruby programming and web development. In the context of a web application, for example, you can easily think of content or functionality on a website you've visited that is only available to a user if that user is logged in.

###IMPLEMENTING CONTROL FLOW

There are a number of ways to tell your program to conditionally execute certain code, the basic forms of which are:

+ `if`, `else`, and `elsif` statements,
+ `case` statements,
+ loops.

In this reading, we're going to discuss the first group of these "conditional" statements: `if`, `else`, and `elsif`.

###IF STATEMENTS
One of the most common ways to enact control flow is the `if` statement. Whatever block of code that follows the `if` statement will get evaluated—i.e. read and enacted by the computer. If this evaluation of the `if` statement results in `true`, then the code through to the associated end statement will run.

Let's look at a few examples:

```
if 5 > 2
  print "5 is greater than 2"
end
```

The code above will print `"5 is greater than 2"` because the if statement evaluates as `true`.

Meanwhile:

```
if 2 > 5
  puts "2 is greater than 5"
end
```

The code above will not print anything because the `if` statement evaluates as `false`.

So what if we want our program to print something else when the `if` condition evaluates as `false`?

###THE ELSE KEYWORD
To accomplish this, we can follow an `if` statement with an `else` statement. Take a look:

```
if false
   puts "This will never get printed because the above
     statement evaluates to false."
else
   puts "This will get printed!"
end
```

An `else` statement sets a "default" condition for when your `if` statement's conditional evaluates as `false`. Every condition that doesn't evaluate as `true` will instead pass through the `else` statement.

###FURTHER EXAMPLES

So far, we've seen if statements that rely on the explicit use of the `true` and `false` booleans. Let's look at some examples that require a little more thought.

**EXAMPLE 1**

```
if 6 + 3 == 9
  puts "Giraffes have no vocal cords."
end
# └── "Giraffes have no vocal cords."
```

The code above will print `Giraffes have no vocal cords`. Since `6 + 3` equals `9` (i.e. `9` is equal to `9`), the `if` statement's conditional evaluates as `true`.

**Top-tip**: Remember that the comparative operator `==` ("double-equals") is used to check equality. This is distinct from the assignment operator `=` ("single-equals"), which is used to set the value of a variable.

**EXAMPLE 2**

```
if 6 + 3 < 5
  puts "The hummingbird is the only animal that can fly
   backwards"
end
```

The code above will not print anything because `6 + 3`, which is equivalent to `9`, is not less than `5`, making the `if` statement's conditional evaluate as `false`.

**EXAMPLE 3**

```
dog = "satisfied"

if dog == "hungry"
  puts "Refilling food bowl."
else
  puts "Reading newspaper."
end

#  └── "Reading newspaper."
```

###ELSIF STATEMENTS

Sometimes, we want to control the flow of our program based on more than one condition. For example, if I am hungry, then I will get a snack. If I am thirsty, then I will get a drink of water. Otherwise, I will stay here and continue learning more about control flow.

We can add additional layers of complexity to our `if` and `else` statements by using the `elsif` keyword.

Let's add an `elsif` statement to Example 3 from above:

```
dog = "thirsty"

if dog == "hungry"
  puts "Refilling food bowl."
elsif dog == "thirsty"
  puts "Refilling water bowl."
else
  puts "Reading newspaper."
end

#  └── "Refilling water bowl."
```

We can cascade as many elsif statements as we wish, however `elsif` statements can only be used following an `if` statement, and must precede the associated `else` statement (if used).

```
dog = "cuddly"

if dog == "hungry"
  puts "Refilling food bowl."
elsif dog == "thirsty"
  puts "Refilling water bowl."
elsif dog == "playful"
  puts "Playing tug-of-war."
elsif dog == "cuddly"
  puts "Snuggling."
else
  puts "Reading newspaper."
end

#  └── "Snuggling."
```

##HASHES

Hashes also store objects in Ruby. However, they differ from arrays in that they function like dictionaries. Instead of a simple comma separated list, hashes are composed of key/value pairs. Each key points to a specific value––just like a word and a definition in a regular dictionary.

Hashes look like this:

~~~
{"i'm a key" => "i'm a value!", "key2" => "value2"}
~~~

The curly brackets denote the hash and this particular hash has two key/value pairs.

###CREATING HASHES
Hashes can be created with **literal constructors** and **class constructors**.

+ **The Literal Constructor**: You can create a hash by simply writing key/value pairs enclosed in curly braces.

+ **The Class Constructor**: Or, you can use the `Hash.new` syntax, which would create an empty hash, `{}`.

##Puts & Print

The puts (short for "out*put s*tring") and print commands are both used to display in the console the results of evaluating Ruby code. The primary difference between them is that puts adds a newline after executing, and print does not.

```
3.times { print "Hello!" }
# > Hello!Hello!Hello!

3.times { puts "Hello!" }
# > Hello!
# > Hello!
# > Hello!
```

By default, Ruby doesn't display any output. The methods puts and print are a great way to explicitly tell the program to display specific information. Without these printing methods, Ruby will read the line, but not print anything out.

###RETURNING VALUES

What methods like puts and print allows us to output to the console are different from Ruby's concept of a return value.

A return value is the data returned to the program by the execution of a method, the assignment of a variable, actually...

Everything in Ruby has a return value!

For instance:


Code  |   Return Value
------|---------------
`"Hello world"` |	`"Hello world"`
`6 + 3`	| `9`
`president = "Obama"`	| `"Obama"`
`total = 6 + 3` | 	`9`
`puts "hello world"`	| `nil`
`print "hello world"`	| `nil`


You may notice that the `puts` and `print` methods, when run in IRB, print values on the screen and then display a line like this: `=> nil`. This is because `puts` and `print` may print the value you want, but instead of returning that value, they return `nil`.

###RETURN VALUES OF METHODS
Methods are like vending machines. When you use a vending machine you just put in two arguments, the number (C7) and your money. We already know how to use arguments, but then your vending machine might do two things. One, it will make a noise saying that everything worked, beep beep. Then it gives you the soda. The soda is the return type. But those beeps? Are you able to do anything with them? Nope! That's like puts: it just tells you stuff and then goes into the ether! Gone forever.

Every method in Ruby returns a value by default, even custom ones. This returned value will be the value of the last statement.

For example, let's look at this method called `restaurant`:

```
def restaurant
  restaurant_name = "Guy's American Kitchen & Bar"
  cuisine = "american"
  motto = "Welcome to Flavor Town!"
end
```
The return value of the restaurant method is `"Welcome to Flavor Town!"` because that was the last statement evaluated.

Say you're the best chef in the world, Guy Fieri. To make a method that just prints your name and returns `nil`, you could write:

```
def print_name
  puts "Guy Fieri"
end
```

To write a method that returns your name but doesn't print anything, you could write:

```
def return_name
  "Guy Fieri"
end
```

To both print and return your name, you could write:

```
def print_and_return_name
  puts "Guy Fieri"
  "Guy Fieri"
end
```

If you accidentally switched the order of the lines inside the method:

```
def broken_print_and_return_name
  "Guy Fieri"
  puts "Guy Fieri"
end
```

The method would instead print `"Guy Fieri"` and return `nil`. This is because the last line that was evaluated was `puts ...` and the return value of a `puts`, as seen in the table above is always `nil`.

###THE RETURN KEYWORD

There is one other way to return a value from a method and that is to use the `return` keyword.

Let's take a look:

```
def stylish_chef
  best_hairstyle = "Guy Fieri"
  return "Martha Stewart"
  "Guy Fieri"
end
```

You may have expected the return value to be "Guy Fieri". However, the return value of the above method is actually `=> Martha Stewart`!

The return keyword will disrupt the execution of your method. If you employ it, your method will return whatever you have explicitly told it to (in this case, `"Martha Stewart"`), and terminate.

The explicit use of the `return` keyword is generally avoided by many Rubyists.

###WHY RETURN VALUES MATTER
Return values are how different parts of your program communicate with one another. You don't have to worry too much about this for now, but as you start to build more complicated programs, you'll find that the return value of one method might be operated on by a subsequent method.

Let's look at a very basic example. Earlier, in IRB, we set a variable `total` equal to the return value of adding `6 + 3`. If you've left IRB, drop back in and re-create your `total` variable as the sum of `6 + 3`.

On the next line, execute `total + 17`. You should see a return value of `=> 26`. Thus, the return value of one operation (`6 + 3`) was used to execute further operations (the addition of `17`).

As we've just done, you'll find that we will often store return values in variables so that we can use them later.

##String Methods 
1. Puts
 + a. .to_s, .to_i, .to_f
 + b. .reverse : reverses order
 + c. .length : # of characters (not letters, so counts spaces too)
 + d. .upcase : changes every lowercase to uppercase
 + e. .downcase : change every uppercase to lowercase
 + f. .swapcase : swaps cases
 + g. .capitalize : capitalized first character!! not first letter. Downcases everything else. 
 + h. str.center(how wide you want the centered string to be)
 + Ex: line_width= 50 (so that you can easily go back and change one variable instead of all the lines) 
     str.center(line_width)
 i. str.ljust( line_width), str.rjust(line_width)

2. gets(.chomp)

##Math
 + a. ' ** ' : exponent
   
   + 5 ** 2= 25
   + 5 ** 0.5= 5^0.5
   
 + b. **'%'** : modulus (gets you the remainder of operation)
    
    + 7%3= 1 (7/3= 2 r1)
    
 + c. **'.abs'** : absolute value
 + d. **'rand( )'** : random number generator  
     + srand : seed. To repeat the same random numbers. 
 + e. **'Math ::'** : like a scientific calc. Treat like a variable. 
     + 'Math :: PI' : constant, doesn't vary. 
    + 'puts (Math.cos(Math::PI/3))': 0.5